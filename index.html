<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/02/%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-12-02T07:22:04.000Z" itemprop="datePublished">2024-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/02/%E6%B5%8B%E8%AF%95/">测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><ul>
<li><h4 id="Selenium框架"><a href="#Selenium框架" class="headerlink" title="Selenium框架"></a>Selenium框架</h4></li>
</ul>
<hr>
<p>Web应用程序测试，只能测试Web应用程序；</p>
<ul>
<li><p>安装框架</p>
</li>
<li><p>下载浏览器驱动，将可执行文件放置在Python环境变量配置目录；</p>
<!--即Python安装目录-->

<!--可能出现无法找到该驱动程序的环境变量的问题-->

<!--驱动实例开启会话时直接将环境变量指向驱动程序路径-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver = webdriver.Edge(executable_path=r&quot;D:\path\msedgedriver.exe&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="打开网页"><a href="#打开网页" class="headerlink" title="打开网页"></a>打开网页</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;网址&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="等待方式"><a href="#等待方式" class="headerlink" title="等待方式"></a>等待方式</h4><ul>
<li><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">time.sleep(3)</span><br><span class="line">或</span><br><span class="line">from time import sleep </span><br><span class="line">sleep(3)</span><br></pre></td></tr></table></figure>

<!--关闭页面的时间，等待3秒，强制等待，需要导入-->
</li>
<li><h5 id="implicitly-wait"><a href="#implicitly-wait" class="headerlink" title="implicitly_wait"></a>implicitly_wait</h5><!--智能等待（隐形等待），不需要导入-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(&#x27;//*[@id=&quot;s-top-loginbtn&quot;]&#x27;).click()</span><br></pre></td></tr></table></figure>

<p>满足条件及关闭；</p>
</li>
<li><h5 id="WebDriverWait-常用"><a href="#WebDriverWait-常用" class="headerlink" title="WebDriverWait(常用)"></a>WebDriverWait(常用)</h5><!--显性等待-->

<!--需要明确等待条件和等待上限-->

<!--场景：操作引起页面的变化，要操作变化的元素时，要使用显性等待-->

<p>需要传入的参数：</p>
<!--1.driver：浏览器驱动-->

<!--2.timeout：等待上限（秒）-->

<!--3.poll_frequency：检测的轮询间隔（默认0.5秒）-->

<!--4.ignored_exceptions：超时后抛出的异常信息-->

<hr>
</li>
</ul>
</li>
<li><h4 id="常用方法和模块"><a href="#常用方法和模块" class="headerlink" title="常用方法和模块"></a>常用方法和模块</h4><ul>
<li><h5 id="Expected-Conditions模块"><a href="#Expected-Conditions模块" class="headerlink" title="Expected Conditions模块"></a>Expected Conditions模块</h5><p>和<strong>WebDriverWait</strong>配合使用，动态等待页面上元素出现或者消失；</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nbkhic/p/4885041.html">python selenium expected_conditions使用实例 - 乙醇 - 博客园 (cnblogs.com)</a></p>
</li>
<li><h5 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h5><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38648367/article/details/127729489">Python+selenium自动化八大元素定位方法及实例（超详细）_selenium通过属性定位-CSDN博客</a></p>
<!--基本语法：driver.find_element(By.属性,"value")-->
</li>
<li><h5 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element_to_be_clickable()</span><br></pre></td></tr></table></figure>

<!--返回节点元素，即为可点击节点-->

<!--参考： (https://blog.csdn.net/weixin_45081575/article/details/112306723)-->
</li>
<li><h5 id="ActionChains模块"><a href="#ActionChains模块" class="headerlink" title="ActionChains模块"></a>ActionChains模块</h5><!--动作链-->

<!--适用情况：需要鼠标操作时-->

<p>调用时不会立刻执行，将所有操作顺序按顺序放在一个队列里，调用perform()时，时间依次执行；</p>
<ul>
<li><h5 id="链式写法"><a href="#链式写法" class="headerlink" title="链式写法"></a>链式写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu = driver.find_element_by_css_selector(&quot;.nav&quot;)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(&quot;.nav #submenu1&quot;)</span><br><span class="line">ActionChains(driver).move_to_element(menu).click(hidden_submenu).perform()</span><br></pre></td></tr></table></figure>

<!--先找到页面元素，move_to_element指让鼠标指针移动到该元素上，模拟点击动作-->
</li>
<li><h5 id="分布写法"><a href="#分布写法" class="headerlink" title="分布写法"></a>分布写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu = driver.find_element_by_css_selector(&quot;.nav&quot;)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(&quot;.nav #submenu1&quot;)</span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line">actions.move_to_element(menu)</span><br><span class="line">actions.click(hidden_submenu)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>具体方法见：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxbmaomao/p/10389786.html">Selenium之动作链（ActionChains） - liangxb - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h4 id="unittest框架"><a href="#unittest框架" class="headerlink" title="unittest框架"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=unittest&spm=1001.2101.3001.7020">unittest</a>框架</h4><p>python自带单元测试框架；</p>
<p>一般是最小可测试单元在与其他程序部分隔离的情况下进行检查和验证；</p>
<!--一般最小可测试单元指函数或类-->

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54219272/article/details/123265794">自动化测试——unittest框架_加上unittest测试框架,数据驱动,数据断言等内容。-CSDN博客</a></p>
<h5 id="核心元素："><a href="#核心元素：" class="headerlink" title="核心元素："></a>核心元素：</h5><ul>
<li><h5 id="TestCase（测试用例）"><a href="#TestCase（测试用例）" class="headerlink" title=". TestCase（测试用例）"></a><strong>. TestCase（测试用例）</strong></h5></li>
<li><h5 id="TestSuite-测试套件"><a href="#TestSuite-测试套件" class="headerlink" title=". TestSuite(测试套件)"></a>. TestSuite(测试套件)</h5><!--用来组装打包管理多个测试用例文件的-->
</li>
<li><h5 id="TestRunner-测试执行）"><a href="#TestRunner-测试执行）" class="headerlink" title=". TestRunner(测试执行）"></a>. TestRunner(测试执行）</h5><!--执行TestUite测试套件的-->
</li>
<li><h5 id="TestLoader-装载器）"><a href="#TestLoader-装载器）" class="headerlink" title=". TestLoader(装载器）"></a>. TestLoader(装载器）</h5><!--搜索指定文件夹内指定字母开头的模块下test开始的方法并将符合要求的方法加载到测试套件中-->

<ol>
<li>根据测试类加载测试用例</li>
<li>根据测试模块（测试类所处模块）加载测试用例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from test_math_method import TestMathMethod</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line">loader = unittest.TestLoader()</span><br><span class="line"></span><br><span class="line">#从测试模块里面加载测试用例</span><br><span class="line">suite.addTest(loader.loadTestsFromTestCase(TestMathMethod))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">import test_math_method</span><br><span class="line">#from test_math_method import TestMathMethod</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line">loader = unittest.TestLoader()</span><br><span class="line"></span><br><span class="line">suite.addTest(loader.loadTestsFromModule(test_math_method))</span><br></pre></td></tr></table></figure>

<!--两个方法没有很大的区别，第一个是从文件中导入测试类进行测试；-->

<!--第二个是先导入测试文件，从模块中直接加载测试用例-->
</li>
<li><h5 id="Fixture-固定装置）"><a href="#Fixture-固定装置）" class="headerlink" title=". Fixture(固定装置）"></a>. Fixture(固定装置）</h5><!--两个固定的函数，一个初始化时使用，一个结束时使用--></li>
</ul>
<hr>
<h5 id="用例规则："><a href="#用例规则：" class="headerlink" title="用例规则："></a>用例规则：</h5><ul>
<li><p>导包</p>
<!--import unittest-->
</li>
<li><p>测试类继承unittest.TestCase</p>
</li>
<li><p>测试方法必须以test_开头</p>
</li>
</ul>
<h5 id="方法级别："><a href="#方法级别：" class="headerlink" title="方法级别："></a>方法级别：</h5><ul>
<li><p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def setUp()</span><br></pre></td></tr></table></figure>

<p>测试方法执行前</p>
</li>
<li><p>释放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def tearDown()</span><br></pre></td></tr></table></figure>

<p>测试方法执行后</p>
</li>
</ul>
<!--与此相同的还有类级别，setUpClass();tearDownClass()-->

<!--类方法使用 @classmethod 修饰-->

<hr>
<h5 id="断言："><a href="#断言：" class="headerlink" title="断言："></a>断言：</h5><!--程序判断预期结果和实际结果是否相符-->

<ul>
<li><p>使用方法：</p>
<p>self.断言方法</p>
<!--eg：self.assert'表达式'(预期值，实际值);句式：assertEqual,assertTrue--></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h4 id="Robot-Framwork框架"><a href="#Robot-Framwork框架" class="headerlink" title="Robot Framwork框架"></a>Robot Framwork框架</h4></li>
</ul>
<hr>
<h4 id="具体内容："><a href="#具体内容：" class="headerlink" title="具体内容："></a>具体内容：</h4><ul>
<li><p>接口测试</p>
</li>
<li><p>UI测试</p>
</li>
<li><p>持续集成</p>
</li>
</ul>
<hr>
<h4 id="一些有用的知识"><a href="#一些有用的知识" class="headerlink" title="一些有用的知识"></a>一些有用的知识</h4><ul>
<li><h5 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h5><h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><ul>
<li><p>标准接口规范，处理HTML和XML文件的标准API;</p>
</li>
<li><p>中立于平台和语言的接口，允许程序和脚本动态访问，更新文档的内容结构和样式；</p>
</li>
</ul>
<h5 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h5><ul>
<li><h5 id="元素："><a href="#元素：" class="headerlink" title="元素："></a>元素：</h5><p>文档中都有标签的为元素</p>
</li>
<li><h5 id="节点："><a href="#节点：" class="headerlink" title="节点："></a>节点：</h5><p>都有的内容是节点</p>
<!--标签，属性，文本-->
</li>
<li><h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p>一个页面是一个文档</p>
</li>
</ul>
<p>文档包含节点，节点包含元素；</p>
<h5 id="类似于："><a href="#类似于：" class="headerlink" title="类似于："></a>类似于：</h5><p><img src="https://img2020.cnblogs.com/blog/2340361/202109/2340361-20210910201929078-1181253470.gif"></p>
<h5 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction() &#123; document.getElementById(&quot;p1&quot;).innerHTML = &quot;我喜欢吃&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=&quot;p1&quot;&gt;我喜欢吃藕&lt;/p&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;试一试&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;上面的段落被一段脚本改变了。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<!--修改了一段内容-->

<hr>
</li>
<li><h5 id="unittest"><a href="#unittest" class="headerlink" title="unittest"></a>unittest</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suite1 = unittest.TestLoader().discover(&#x27;Test1&#x27;, pattern = &quot;Test*.py&quot;)</span><br><span class="line">suite2 = unittest.TestLoader().discover(&#x27;Test2&#x27;, pattern = &quot;Test*.py&quot;)</span><br><span class="line">alltests = unittest.TestSuite((suite1, suite2))</span><br><span class="line">unittest.TextTestRunner(verbosity=2).run(alltests)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先在指定的目录下搜寻指定文件；</p>
<!--pattern= ：指定文件名模式，表示加载文件名以Test开头以.py结尾的文件-->
</li>
<li><p>将测试用例或套件整合到一个测试套件内执行；</p>
</li>
<li><p>执行测试；</p>
<!--verbosity=2 :指详细的输出（包括测试的名称和运行结果）--></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/02/%E6%B5%8B%E8%AF%95/" data-id="cm4tyjjk2000cekf53549gycm" data-title="测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于部署平台时的问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-11-17T08:27:49.000Z" itemprop="datePublished">2024-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/">关于部署平台时的问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="平台Knative"><a href="#平台Knative" class="headerlink" title="平台Knative"></a>平台Knative</h4><ul>
<li>首先Knative建立在K8s集群上；</li>
<li>部署K8s用到的工具：<ul>
<li>docker(podman)</li>
<li>debian</li>
<li>Kubectl</li>
<li>Minikube</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h4><!--详情见[如何在 Debian 11 上使用 Minicube 设置 Kubernetes 集群 (linux-console.net)](https://cn.linux-console.net/?p=4101)-->

<ul>
<li>需要先安装Snap包</li>
<li>用Snap包创建符号链接</li>
<li>添加至配置文件</li>
</ul>
<hr>
<h4 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h4><!--同上-->

<ul>
<li><p>在启动Minikube时，要求podman 最低版本为4.9.0</p>
<ul>
<li><p>更新podman出现了一系列问题导致无法直接更新，从主机github上下载4.9.0的压缩包；</p>
</li>
<li><p>通过xftp传输至debian中进行解压；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf podman-remote-static-linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<!--解压的文件可能不是直接可执行的文件，需移动到正确的位置并重命名-->
</li>
<li><p>赋予执行权力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x 文件路径/podman</span><br></pre></td></tr></table></figure>
</li>
<li><p>容易出现环境变量问题</p>
<p>确认文件是否在目标目录，存在但无法访问，即需添加环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:目录</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>运行时podman易出现驱动问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -n -k podman version --format &#123;&#123;.Version&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将当前用户添加至配置文件，即允许无密码使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br><span class="line">&lt;你的用户名&gt; ALL=(ALL) NOPASSWD:/usr/bin/podman</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>gcr.io 容器注册表连接失败</p>
<!--替换镜像源-->
</li>
<li><p>运行时容易提示无权限：</p>
<p>启用Podman的rootless模式</p>
</li>
<li><p>podman更新后配置易出现问题，如没有正确启动或没有配置好</p>
<ul>
<li><p>首先初始化Podman</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">podman machine init</span><br><span class="line">podman machine start</span><br><span class="line">//检查是否正常启动</span><br><span class="line">podman info</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="cm4tyjjk00008ekf52dmrgw0w" data-title="关于部署平台时的问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于K8s和Knative" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/" class="article-date">
  <time class="dt-published" datetime="2024-11-14T12:57:52.000Z" itemprop="datePublished">2024-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/">关于K8s和Knative</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="关于K8s和Knative"><a href="#关于K8s和Knative" class="headerlink" title="关于K8s和Knative"></a>关于K8s和Knative</h2><h2 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h2><ul>
<li><h4 id="组件架构："><a href="#组件架构：" class="headerlink" title="组件架构："></a>组件架构：</h4><ul>
<li><h5 id="控制节点（master）"><a href="#控制节点（master）" class="headerlink" title="控制节点（master）"></a>控制节点（master）</h5><p>四个重要组件：</p>
<ul>
<li><p><strong>ApiServer</strong> </p>
<p>资源操作入口</p>
<!--提供各类型资源对象的增删改查等HTTP Rest接口；-->


</li>
<li><p><strong>Scheduler</strong> </p>
<p>集群资源调度，按策略将Pod调度到node</p>
</li>
<li><p><strong>ControllerManager</strong> </p>
<p>维护集群状态</p>
</li>
<li><p><strong>Etcd</strong> </p>
<p>相当于K8s的数据库</p>
</li>
</ul>
</li>
<li><h5 id="工作节点（node）"><a href="#工作节点（node）" class="headerlink" title="工作节点（node）"></a>工作节点（node）</h5><p>提供环境：</p>
<ul>
<li><strong>Kubelet</strong> </li>
<li><strong>KubeProxy</strong> </li>
<li><strong>Docker</strong></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="K8s控制器"><a href="#K8s控制器" class="headerlink" title="K8s控制器"></a>K8s控制器</h4><h4 id=""><a href="#" class="headerlink" title=""></a><!--Replicaset和Deployment--></h4><ul>
<li><h4 id="Replicaset"><a href="#Replicaset" class="headerlink" title="Replicaset"></a><strong>Replicaset</strong></h4><p>副本控制器（rs），控制由其管理的pod，使pod副本的数量始终维持在预设的个数；</p>
<ul>
<li><p>组成部分：</p>
<ul>
<li><p><strong>用户期望的pod副本数</strong></p>
</li>
<li><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a><strong>标签选择器</strong></h5><!--选定pod由自己管理-->

</li>
<li><h5 id="pod资源模板"><a href="#pod资源模板" class="headerlink" title="pod资源模板"></a><strong>pod资源模板</strong></h5><!--新建pod的模板--></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编写一个ReplicaSet资源清单</span></span><br><span class="line">[<span class="string">root@k8s-master1</span> <span class="string">~</span>]<span class="comment"># cat replicaset.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">guestbook</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">php-redis</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">yecc/gcr.io-google_samples-gb-frontend:v3</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span>  <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​      </p>
<pre><code>- **Deployment**
</code></pre>
<hr>
<h3 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h3><p>自带客户端，可用来直接操作K8s集群</p>
<ul>
<li><p>K8s命令行工具，可以对其集群运行命令，部署应用，监测管理集群资源和查看日志；</p>
<!--提到集群的控制面：容器编排层，暴露了API和接口来定义，部署容器和管理容器的生命周期-->

<!--原理：输入的转化为REST API调用，将返回结果输出-->

<ul>
<li><h5 id="容器编排层"><a href="#容器编排层" class="headerlink" title="容器编排层"></a>容器编排层</h5><ol>
<li>保证在多个主机上配置和管理容器，保障容器的运行；</li>
<li>自动分配保证负载的平衡；</li>
<li>根据需求自动增减容器的数量（弹性收缩）；</li>
<li>监控容器的健康状态，对出现问题的容器自动重启；</li>
<li>提供容器间的通信机制；</li>
</ol>
</li>
</ul>
</li>
<li><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>使用以下语法从终端窗口运行 <code>kubectl</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl [command] [TYPE] [NAME] [flags]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>command</code>：指具体操作（create,get等）</p>
</li>
<li><p>对类型相同的资源分组</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="一些区分"><a href="#一些区分" class="headerlink" title="一些区分"></a>一些区分</h3><ul>
<li><h4 id="Kubectl-1"><a href="#Kubectl-1" class="headerlink" title="Kubectl"></a>Kubectl</h4><ul>
<li><p>K8s<strong>命令行工具</strong>；</p>
</li>
<li><p>操作K8s集群的工具，允许用户发送请求给K8s API Server管理集群中的资源；</p>
<!--K8s操作的基础工具--></li>
</ul>
</li>
<li><h4 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h4><ul>
<li><p><strong>本地集群工具</strong>，适于开发和测试；</p>
</li>
<li><p>提供轻量级本地集群，简单的环境来运行容器化的应用；</p>
<!--在本地机器启动一个单节点的集群，可用于部署平台,支持虚拟化环境-->

<!--提供本地开发环境--></li>
</ul>
</li>
<li><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><ul>
<li><p>核心组件，节点上的代理程序；</p>
</li>
<li><p>集群中每个节点的守护进程，直接和容器运行时交互；</p>
<!--负责节点管理--></li>
</ul>
</li>
<li><h4 id="Knative"><a href="#Knative" class="headerlink" title="Knative"></a>Knative</h4><ul>
<li>无服务平台</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/" data-id="cm4tyjjk00007ekf5ejal04qr" data-title="关于K8s和Knative" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-无服务白皮书-11-13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/13/%E6%97%A0%E6%9C%8D%E5%8A%A1%E7%99%BD%E7%9A%AE%E4%B9%A6-11-13/" class="article-date">
  <time class="dt-published" datetime="2024-11-13T12:27:35.000Z" itemprop="datePublished">2024-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/13/%E6%97%A0%E6%9C%8D%E5%8A%A1%E7%99%BD%E7%9A%AE%E4%B9%A6-11-13/">无服务白皮书(11.13)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="无服务平台"><a href="#无服务平台" class="headerlink" title="无服务平台"></a>无服务平台</h2><h4 id="无服务技术平台"><a href="#无服务技术平台" class="headerlink" title="无服务技术平台"></a>无服务技术平台</h4><ul>
<li><h4 id="Faas"><a href="#Faas" class="headerlink" title="Faas"></a><strong>Faas</strong></h4><p>提供事件驱动的计算</p>
</li>
<li><h4 id="Bass"><a href="#Bass" class="headerlink" title="Bass"></a><strong>Bass</strong></h4><p>基于第三方 API 的服务，代替应用中的常用功能</p>
</li>
<li><p><strong>提到的平台</strong></p>
<p>BaaS 平台，FaaS 平台，OpenWhisk，Cloud Functions、 Azure Functions；</p>
<p>Openfaas、Fission、Kubeless、Knative、 IronFunctions ；</p>
</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p><strong>纯粹按需使用计费</strong></p>
</li>
<li><p><strong>分布式细粒度扩缩容</strong></p>
<p>（满足较小的占用空间，细粒度自动扩缩容）</p>
</li>
<li><p><strong>事件驱动的应用</strong>，Serverless 可以完美适应他们</p>
<p>（基于本地数据获取是否触发函数调用链做基本的决策，未被触发则无服务平台没有资源消耗）</p>
<!--即意味着部署在边缘设备上的收集数据的设备先进行数据收集和基本的决策，边缘系统中可能有预设的函数，若数据值到达某个条件即触发函数-->
</li>
<li><p><strong>无状态生命周期</strong></p>
<p>系统中的函数或任务不依赖过去的历史数据或执行状态，每次都为全新的，适合事件驱动，因为每个事件的处理是全新的；</p>
<!--Unikernel：单地址空间机器镜像,将应用程序和操作系统内核合并成单一镜像的操作系统设计-->
</li>
<li><p><strong>突发工作负载</strong></p>
<!--突发工作负载：系统需应对的、突然出现的高峰流量或大量请求，这些工作负载通常是短暂或间歇性的-->

<p>无服务技术能适应的原因：</p>
<ul>
<li><p><strong>自动扩缩容：</strong></p>
<p>在工作负载增大时，自动扩展资源，减少则释放；</p>
</li>
<li><p><strong>资源供给：</strong></p>
<p>不是提前分配资源而是按需分配；</p>
</li>
</ul>
<p>总体来说能提高系统的响应速度；</p>
</li>
</ul>
<h4 id="雾计算场景下的无服务边缘计算关键特性"><a href="#雾计算场景下的无服务边缘计算关键特性" class="headerlink" title="雾计算场景下的无服务边缘计算关键特性"></a>雾计算场景下的无服务边缘计算关键特性</h4><ul>
<li><p>低时延计算卸载、平台间协同、延时优化、随机数据分析、边缘节点间业务协同、 有状态划分等</p>
<!--雾计算：将计算储存和网络服务从云端推向靠近数据源的边缘节点--></li>
</ul>
<h4 id="技术挑战"><a href="#技术挑战" class="headerlink" title="技术挑战"></a>技术挑战</h4><ul>
<li>冷启动产生的长延时，不实用的为云设计的成本效益模型，持续工作负载和边缘 AI 应用（无 GPU 支持）的不适用性；</li>
<li>缺失位置和能源感知， 未考虑分布式网络，无效的数据迁移，间断资源说明，可靠性和容错 考虑，无效的资源调用的可能性，安全问题，不成熟的函数触发，缺失仿真工具；</li>
</ul>
<h4 id="无服务器边缘计算网络架构"><a href="#无服务器边缘计算网络架构" class="headerlink" title="无服务器边缘计算网络架构"></a>无服务器边缘计算网络架构</h4><!--基础功能-->

<ul>
<li><h5 id="智能业务与应用"><a href="#智能业务与应用" class="headerlink" title="智能业务与应用"></a>智能业务与应用</h5><ul>
<li><p>能自适应和相应动态环境需求的应用，利用边缘计算的低时延，弹性扩展，分布式资源；</p>
</li>
<li><p>通过API（函数即服务）调用和底层网络资源的编排实现跨网络和跨域的无缝协作</p>
<!--API调用：指边缘节点收集到数据后，调用封装的函数分析等--></li>
</ul>
</li>
<li><h5 id="基于Serverless-的服务管理系统"><a href="#基于Serverless-的服务管理系统" class="headerlink" title="基于Serverless 的服务管理系统"></a>基于Serverless 的服务管理系统</h5><!--对各种无服务进行全面的管理，监控和调度-->

<p>通过<strong>管理 Serverless 服务的生命周期</strong>实现协调不同服务之间的调用、资源调度、负载均衡等工作；</p>
<ul>
<li><h5 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h5></li>
<li><h5 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h5><p>将 Serverless 服务（如函数、API 等）自动部署到计算平台上。系统管理平台负责服务的自动化部署、配置和监控；</p>
</li>
<li><h5 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h5><p>在分布式系统中，自动识别并定位网络中可用的服务实例；</p>
</li>
<li><h5 id="服务调度（负载均衡）"><a href="#服务调度（负载均衡）" class="headerlink" title="服务调度（负载均衡）"></a>服务调度（负载均衡）</h5><p>将流量或请求智能地分配到多个可用的服务实例上，以实现高效的资源利用并避免系统过载；</p>
</li>
<li><h5 id="协同调度"><a href="#协同调度" class="headerlink" title="协同调度"></a>协同调度</h5></li>
</ul>
</li>
<li><h5 id="边缘网络控制器及边缘编排管理器"><a href="#边缘网络控制器及边缘编排管理器" class="headerlink" title="边缘网络控制器及边缘编排管理器"></a>边缘网络控制器及边缘编排管理器</h5><ul>
<li><p><strong>边缘网络控制器</strong></p>
<p>连接所有分布式的边缘计算节点，协调节点间的网络通信；</p>
<p>优化数据传输路径和调度策略；</p>
</li>
<li><p><strong>边缘编排管理器</strong></p>
<p>整合所有计算资源和存储资源，自动进行资源调度；</p>
<p>实时扩展或缩减边缘计算节点的计算和存储资源；</p>
<p>确保系统的资源利用最大化，同时根据需求自动扩展或收缩资源。</p>
</li>
</ul>
</li>
<li><h5 id="分布式边缘计算网络基础设施资源"><a href="#分布式边缘计算网络基础设施资源" class="headerlink" title="分布式边缘计算网络基础设施资源"></a>分布式边缘计算网络基础设施资源</h5><p>主要由边缘计算节点和边缘网络设备组成；</p>
</li>
</ul>
<h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><ul>
<li><h5 id="基于-Serverless-的服务管理技术"><a href="#基于-Serverless-的服务管理技术" class="headerlink" title="基于 Serverless 的服务管理技术"></a>基于 Serverless 的服务管理技术</h5><ul>
<li><p>无需管理底层基础设施，专注与编写函数，平台处理资源的分配扩展调度；</p>
</li>
<li><p>核心功能：</p>
<p><strong>服务部署</strong>（确定函数在哪部署和在哪种资源上运行）；<strong>服务发现</strong>（让服务可以被其他组件调用）；</p>
<p><strong>服务调度</strong>（确保高效的负载均衡和资源利用）；</p>
</li>
</ul>
</li>
<li><h5 id="资源管理编排技术"><a href="#资源管理编排技术" class="headerlink" title="资源管理编排技术"></a>资源管理编排技术</h5><p>主要对<strong>容器（K8S实现Docker管理编排）</strong>和<strong>Unikernal</strong>两种计算载体的管理编排进行介绍；</p>
</li>
<li><h5 id="网络控制管理技术"><a href="#网络控制管理技术" class="headerlink" title="网络控制管理技术"></a>网络控制管理技术</h5><!--主要介绍了通过以下两种技术实现“时延确定性”和“路径确定性”-->

<!--时延确定性：数据传输延迟可预测，在时间限制内完成任务-->

<!--路径确定性：数据在网络中传输的路径固定且可靠-->

<ul>
<li><h5 id="软件定义网络（SDN）技术"><a href="#软件定义网络（SDN）技术" class="headerlink" title="软件定义网络（SDN）技术"></a>软件定义网络（SDN）技术</h5><p>用于构建边缘网络的控制面，帮助管理和调度计算、网络和存储资源；</p>
<ul>
<li><h5 id="状态感知："><a href="#状态感知：" class="headerlink" title="状态感知："></a>状态感知：</h5><p>定期上报边缘计算节点和网络设备的状态信息；</p>
</li>
<li><h5 id="任务调度："><a href="#任务调度：" class="headerlink" title="任务调度："></a>任务调度：</h5><p>基于SDN的控制面根据实时的资源状态，选择最适合的边缘计算节点处理请求；</p>
</li>
</ul>
</li>
<li><h5 id="时间敏感网络（TSN）技术"><a href="#时间敏感网络（TSN）技术" class="headerlink" title="时间敏感网络（TSN）技术"></a>时间敏感网络（TSN）技术</h5><p>提供确定性网络传输，确保从一个节点到另一个节点的数据传输具有高度可预测性；</p>
</li>
</ul>
</li>
</ul>
<h4 id="开源生态"><a href="#开源生态" class="headerlink" title="开源生态"></a>开源生态</h4><ul>
<li><h5 id="Knative"><a href="#Knative" class="headerlink" title="Knative"></a>Knative</h5><ul>
<li><p>基于 Kubernetes 和 Istio 的 Serverless 开源实现；2</p>
<!--Istio :开源的服务网格（Service Mesh）框架‘，可以和K8s集成-->

<!--具体作用：1.帮助函数间的调用和流量路由；2.允许函数通过服务发现机制和其他微服务通信和流量负载均衡；3.内建的服务间的加密；-->
</li>
<li><p>只需使用几个 YAML 文件就可以轻松地 开始使用 Knative；</p>
</li>
<li><p>为 了解决容器为核心的 Serverless 应用的构建、部署和运行的问题；</p>
</li>
<li><p>包含<strong>Serving</strong> 和 <strong>Eventing</strong> 两大组件:</p>
<!--通过 Kubernetes custom resource definitions (CRDs)来配置与运行-->

<!--具体解释：扩展K8s的方式，允许用户自定义资源对象让K8s进行调度，监控和管理-->

<ul>
<li><p><strong>Serving</strong></p>
<p>基于 Kubernetes 和 Istio 平台部署，运行无状态的应用 和函数;</p>
<p>控制以下特性Revision （修订版本），Configuration （配置）、Route（路由）和 Service（服 务）实现应用的路由、升级策略、自动扩缩容等功能;</p>
</li>
<li><p><strong>Eventing</strong></p>
<p>事件系统，引入 Source（源）、Channel（通道）和 Subscription（订阅）概念，无需特定代码来选择消息代理，自动完成 事件的绑定和触发；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>OpenFaaS</strong></p>
<p>通过将功能打包，无需重复的样 板化编码，简化操作流程；</p>
<!--用户通过简单的 HTTP 请求（REST API）触发和管理函数-->

<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>易用的UI界面，一键安装；</li>
<li>支持Linux，Windows编写函数，打包Docker镜像；</li>
<li>轻量可移植；</li>
<li>支持命令行工具（YAML制作模板，定义函数）；</li>
</ul>
<p>用户通过 CLI 或者 UI 界面，向 OpenFaas 网关发送 REST API 请求，操作平台功能；</p>
<p>平台上所有的服 务和函数都通过默认路由对外暴露；</p>
</li>
<li><p><strong>OpenWhisk</strong></p>
<ul>
<li><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>功能完备的 FaaS 平台，包含<strong>事件驱动</strong>及函数执行 时等核心组件，可以运行在不同的基础架构上；</p>
</li>
<li><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>庞杂的工具和安全性</p>
</li>
</ul>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><ul>
<li><p><strong>Nginx</strong>：Http 反向代理服务器；</p>
<p>整个系统的入口，接收外部请求转给内部Controller 处理；</p>
</li>
<li><p><strong>Controller</strong> ：为Scala语言实现的REST API；</p>
<p>用于内部对象的 CURD（增删改 查）操作和 Action 调用；</p>
</li>
<li><p><strong>CouchDB</strong>：开源的面向文档的数据库管理系统；</p>
<p>通过检索数据查看用户是否存在以及是否有调用对应 Action 的权限；</p>
<p>加载相应的 Action 及运行参数，存入处理结果；</p>
</li>
<li><p><strong>Load Balancer</strong>：</p>
<p>通过不间断的健康检查，可以获得全局的 Invokers 的状态，知悉哪些可以用于处理动作请求；</p>
</li>
<li><p><strong>Kafka</strong>：提供了消息队列功能；</p>
<p>发出来的所有 Action 调用，都会转化成对应 的消息，在 Kafka 里缓存，等待被执行；</p>
</li>
<li><p><strong>Invoker：</strong>各类 Action 的最终执行者；</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/13/%E6%97%A0%E6%9C%8D%E5%8A%A1%E7%99%BD%E7%9A%AE%E4%B9%A6-11-13/" data-id="cm4tyjjk10009ekf54out7wts" data-title="无服务白皮书(11.13)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2024-11-6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/06/2024-11-6/" class="article-date">
  <time class="dt-published" datetime="2024-11-06T09:06:51.000Z" itemprop="datePublished">2024-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/06/2024-11-6/">2024-11-6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><!--脚本-->

<ul>
<li><h4 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h4><ul>
<li><p><code>env</code>命令总是指向<code>/usr/bin/env</code>文件</p>
<!-- eg: +NAME ，意味着查找环境变量中第一个匹配的NAME。（适用于不知道某命令的具体路径）-->
</li>
<li><p><code>/usr/bin/env bash</code>的意思就是，返回<code>bash</code>可执行文件的位置</p>
<!--当bash路径在环境变量里-->
</li>
<li><p><code>-i</code>, <code>--ignore-environment</code>：不带环境变量启动；</p>
</li>
<li><p><code>-u</code>, <code>--unset=NAME</code>：从环境变量中删除一个变量；</p>
</li>
</ul>
</li>
<li><h4 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h4><ul>
<li><p><code>$0</code>：脚本文件名，即<code>script.sh</code></p>
</li>
<li><p><code>$1</code>~&#96;$9&#96;：对应脚本的第一个参数到第九个参数</p>
</li>
<li><p>+#：参数的总数</p>
</li>
<li><p>+@：全部参数，用空格隔开</p>
</li>
<li><p>+*：全部参数，用变量<code>$IFS</code>值的第一个字符分隔</p>
<!--$IFS：环境变量--></li>
</ul>
<p>命令是<code>command -o foo bar</code>，那么<code>-o</code>是<code>$1</code>，<code>foo</code>是<code>$2</code>，<code>bar</code>是<code>$3</code></p>
</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/06/2024-11-6/" data-id="cm4tyjjjt0000ekf55vbm228p" data-title="2024-11-6" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CI-CD-9-27" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/27/CI-CD-9-27/" class="article-date">
  <time class="dt-published" datetime="2024-09-27T12:51:11.000Z" itemprop="datePublished">2024-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/27/CI-CD-9-27/">关于K8s和Knative(9.27)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h3><ul>
<li><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><p>通常包含<strong>Master节点</strong>和<strong>Worker节点</strong>；</p>
<ul>
<li><p><strong>Master节点</strong></p>
<p>负责整个集群的管理和控制</p>
<ul>
<li><p><strong>API服务器</strong>：</p>
<p>处理所有的 REST 请求，作为负载的入口；</p>
</li>
<li><p><strong>调度器</strong>：</p>
<p>负责将 Pod 分配到合适的 Worker 节点；</p>
<p>Pod:</p>
<ul>
<li>K8s中互联的部署单元，每个共享相同的网络命名空间，可通过localhost相互通信，共享存储卷；</li>
</ul>
<!--最小且最简单的K8s对象-->
</li>
<li><p><strong>控制管理器</strong>：</p>
<p>监控集群状态，确保集群的实际状态与期望状态一致；</p>
</li>
<li><p><strong>etcd</strong>：</p>
<p>一个密钥值存储，用于维护集群的状态信息；</p>
<!--可以作为集群数据的后台数据库--></li>
</ul>
</li>
<li><p><strong>Worker节点</strong></p>
<p>实际运行应用程序的位置</p>
<ul>
<li><p><strong>Kubelet</strong>：</p>
<!--节点代理器-->

<p>负责与Master节点通信，确保容器在节点上运行；</p>
<!--负责具体的容器生命周期管理，从数据库中获取信息来管理，上报pod运行状态-->
</li>
<li><p><strong>容器运行时</strong>：</p>
<p>负责实际运行容器，比如Docker或containerd；</p>
</li>
<li><p><strong>Kube-Proxy</strong>：</p>
<p>负责网络代理和负载均衡；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h4><ul>
<li><p>YAML允许使用个感叹号(!)强制转换数据类型；<br>单叹号通常是自定义类型，双叹号是内置类型；</p>
</li>
<li><h4 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h4></li>
<li><p><strong>文本块</strong></p>
<ul>
<li><p>注意“|”与文本之间须另起一行，使用|标注的文本内容缩进表示的块，可以保留块中已有的回车换行；</p>
<p><code>value: |  hello  world!</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><ul>
<li><p>集群中的基本单元</p>
<!--支持多容器在一个中共享网络地址和文件系统-->
</li>
<li><p>每个Pod通过Pause容器（根容器）使其在对应的容器间共享网络和存储</p>
<ul>
<li><p><strong>共享网络资源</strong></p>
<ul>
<li><p>每个Pod被分配唯一的IP地址。所有容器共享网络空间（IP地址和端口）；</p>
</li>
<li><p>与外界通信，分配共享网络资源（使用宿主机的端口映射）</p>
</li>
</ul>
</li>
<li><p><strong>共享存储资源</strong></p>
</li>
<li><p><strong>veth-pair</strong></p>
<!--[Linux 虚拟网络设备 veth-pair 详解，看这一篇就够了 - bakari - 博客园 (cnblogs.com)](https://www.cnblogs.com/bakari/p/10613710.html#:~:text=前面这篇文章介绍)-->

<p>虚拟网路接口，一端连接协议栈，一端彼此相连；</p>
<p>三个经典实验，直接相连、通过 Bridge 相连和通过 OVS 相连；</p>
</li>
</ul>
</li>
</ul>
<h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul>
<li><p>podman pull </p>
<!--镜像拉取，+镜像名称+拉取地址-->
</li>
<li><p>podman tag</p>
<!--镜像标记（添加标签）--></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/27/CI-CD-9-27/" data-id="cm4tyjjjw0001ekf5b7bx0fpk" data-title="关于K8s和Knative(9.27)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式-9-8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-8/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T07:00:19.000Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-8/">设计模式-9.8</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li><p>创建一个代理类作为真实对象的中间层，在对该对象访问时进行控制。</p>
<!--例如购买火车票的代售点作为火车站的代理-->
</li>
<li><p>具体步骤</p>
<ul>
<li><p>创建一个接口；</p>
</li>
<li><p>创建实现接口的实体类和代理类；</p>
<!--代理类通过引用实体类，实现功能-->
</li>
<li><p>实现用户需求；</p>
</li>
</ul>
</li>
<li><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p><strong>与适配器模式区别</strong></p>
<p>适配器模式改变接口</p>
<pre><code>public class ObjectHeadSetAdapter implements IPhoneInterface &#123;
    
    private AndroidInterface androidInterface;

    public ObjectHeadSetAdapter(AndroidInterface androidInterface) &#123;
        this.androidInterface = androidInterface;
&#125;

    @Override
    public void iphoneHeadSet() &#123;
        androidInterface.androidHeadSet();
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>与装饰器模式区别</strong></p>
<p>装饰器模式用于增强功能</p>
</li>
</ul>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ul>
<li><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>将所有请求处理者通过前一对象记住下一个对象的引用连成一条链；</p>
<p>客户将请求发至责任链上即可</p>
</li>
<li><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><ul>
<li><p><strong>抽象处理者</strong>：定义处理请求的接口（抽象处理方法和后继连接）；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//抽象处理者角色</span><br><span class="line">abstract class Handler</span><br><span class="line">&#123;</span><br><span class="line">    private Handler next;</span><br><span class="line">    public void setNext(Handler next)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next=next; </span><br><span class="line">    &#125;</span><br><span class="line">    public Handler getNext()</span><br><span class="line">    &#123; </span><br><span class="line">        return next; </span><br><span class="line">    &#125;   </span><br><span class="line">    //处理请求的方法</span><br><span class="line">    public abstract void handleRequest(String request);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>具体处理者</strong>：实现处理者的处理方法；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//具体处理者角色1</span><br><span class="line">class ConcreteHandler1 extends Handler</span><br><span class="line">&#123;</span><br><span class="line">    public void handleRequest(String request)</span><br><span class="line">    &#123;</span><br><span class="line">        if(request.equals(&quot;one&quot;)) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;具体处理者1负责处理该请求！&quot;);       </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(getNext()!=null) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;没有人处理该请求！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>客户类</strong>：创建处理链，向链头的具体处理者对象提交申请；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package chainOfResponsibility;</span><br><span class="line">public class ChainOfResponsibilityPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        //组装责任链 </span><br><span class="line">        Handler handler1=new ConcreteHandler1(); </span><br><span class="line">        Handler handler2=new ConcreteHandler2(); </span><br><span class="line">        handler1.setNext(handler2); </span><br><span class="line">        //提交请求 </span><br><span class="line">        handler1.handleRequest(&quot;two&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><ul>
<li><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>定义一种语言的语法表示，提供一个解释器解释该语言中的语句。</p>
<!--解析和执行特定语言或表达式-->
</li>
<li><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><ul>
<li><p><strong>抽象表达式</strong>：解释方法的接口（语法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Expression &#123;</span><br><span class="line">    int interpret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终结符表达式</strong>：表示语法中的基本元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class NumberExpression implements Expression &#123;</span><br><span class="line">    private int number;</span><br><span class="line"></span><br><span class="line">    public NumberExpression(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--举例中指加减法，即定义数字-->
</li>
<li><p><strong>非终结符表达式</strong>：表示复杂的规则（将基本元素即终结符表达式组合起来）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class AddExpression implements Expression &#123;</span><br><span class="line">    private Expression leftExpression;</span><br><span class="line">    private Expression rightExpression;</span><br><span class="line"></span><br><span class="line">    public AddExpression(Expression leftExpression, Expression rightExpression) &#123;</span><br><span class="line">        this.leftExpression = leftExpression;</span><br><span class="line">        this.rightExpression = rightExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return leftExpression.interpret() + rightExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上述为加法，减法同上</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解释器</strong>：实现简单的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class InterpreterPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建表达式：10 + (5 - 2)</span><br><span class="line">        Expression number10 = new NumberExpression(10);</span><br><span class="line">        Expression number5 = new NumberExpression(5);</span><br><span class="line">        Expression number2 = new NumberExpression(2);</span><br><span class="line"></span><br><span class="line">        // 5 - 2</span><br><span class="line">        Expression subtractExpression = new SubtractExpression(number5, number2);</span><br><span class="line"></span><br><span class="line">        // 10 + (5 - 2)</span><br><span class="line">        Expression addExpression = new AddExpression(number10, subtractExpression);</span><br><span class="line"></span><br><span class="line">        // 解释最终的表达式</span><br><span class="line">        int result = addExpression.interpret();</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);  // 输出 13</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-8/" data-id="cm4tyjjk2000dekf55zt71w71" data-title="设计模式-9.8" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式-9-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-4/" class="article-date">
  <time class="dt-published" datetime="2024-09-04T08:44:30.000Z" itemprop="datePublished">2024-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-4/">设计模式(9.4)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>- </p>
<ul>
<li><p>成员<strong>私有的静态的</strong></p>
<!--一个类仅有一个静态成员变量来保存唯一的实例-->
</li>
<li><p>构造方式 <strong>私有的</strong></p>
<!--构造函数被声明为私有的-->
</li>
<li><p>对外暴露的获取访问是 <strong>公有的静态的</strong></p>
<!--提供一个访问的全局访问点--即一个公有的静态方法来获取或创建实例-->

<!--使用public static:意味着该变量属于类的而不是类的实例，可以通过类名.变量名直接访问-->
</li>
<li><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><h4 id="饿汉式-建议使用"><a href="#饿汉式-建议使用" class="headerlink" title="饿汉式(建议使用)"></a><strong>饿汉式</strong>(建议使用)</h4><p>在<strong>类加载</strong>时已经创建好该对象，在程序调用时直接返回该单例对象即可；</p>
<!--即不用等到被调用时再去创建-->

<pre><code>public class Singleton&#123;
//在该类中创建一个该类的对象供外界去使用
private static Singleton instance= new Singleton();

// 构造方法 private 化
private Singleton()&#123;

&#125;

// 得到 Singleton 的实例(唯一途径）
public static Singleton getInstance() &#123;
    return instance;
&#125;
</code></pre>
</li>
<li><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a><strong>懒汉式</strong></h4><p>在程序使用对象前，先<strong>判断该对象是否已经实例化</strong>（判空）；</p>
<p>若已实例化直接返回该类对象，否则则先执行实例化操作；</p>
<ul>
<li><p>线程不安全</p>
<!--不支持多线程，无加锁 synchronized--></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    //在该类中创建一个该类的对象供外界去使用</span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    // 构造方法 private 化</span><br><span class="line">    private Singleton()&#123; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到 Singleton 的实例(唯一途径）</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程安全</p>
<!--能很好的在多线程工作，效率低-->

<!--public static synchronized Singleton getInstance()--></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-4/" data-id="cm4tyjjk2000bekf58aoaelye" data-title="设计模式(9.4)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2024-8-17（周总结）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/30/2024-8-17%EF%BC%88%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-08-30T05:51:54.000Z" itemprop="datePublished">2024-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/30/2024-8-17%EF%BC%88%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%89/">2024.8.17（周总结）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="周总结"><a href="#周总结" class="headerlink" title="周总结"></a>周总结</h2><ul>
<li><h4 id="目前的任务"><a href="#目前的任务" class="headerlink" title="目前的任务"></a><strong>目前的任务</strong></h4><ul>
<li>翻译总结下周要讲的论文</li>
</ul>
</li>
<li><h4 id="之前未完成的任务"><a href="#之前未完成的任务" class="headerlink" title="之前未完成的任务"></a><strong>之前未完成的任务</strong></h4><ul>
<li>设计模式还没有学完；</li>
<li>自动化运维看了，但是没有实践；</li>
<li>以及shell命令，一半左右的进度；</li>
</ul>
</li>
<li><h4 id="目前计划"><a href="#目前计划" class="headerlink" title="目前计划"></a>目前计划</h4><ul>
<li>先把翻译的论文整理完；</li>
<li>设计模式看一下能不能搞完，把剩下的看完；</li>
<li>实践一下自动化运维；</li>
</ul>
</li>
<li><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h4><p>比上周多一点进度！</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/30/2024-8-17%EF%BC%88%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%89/" data-id="cm4tyjjjx0002ekf52cm58xqk" data-title="2024.8.17（周总结）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Django(3)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/06/Django(3)/" class="article-date">
  <time class="dt-published" datetime="2024-06-06T02:54:49.000Z" itemprop="datePublished">2024-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/06/Django(3)/">Django3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Django-models中关于blank与null的补充说明"><a href="#Django-models中关于blank与null的补充说明" class="headerlink" title="Django models中关于blank与null的补充说明"></a>Django models中关于blank与null的补充说明</h3><ul>
<li>null 是针对数据库而言，如果 null&#x3D;True, 表示数据库的该字段可以为空。</li>
<li>blank 是针对表单的，如果 blank&#x3D;True，表示你的表单填写该字段的时候可以不填，比如 admin 界面下增加 model 一条记录的时候。直观的看到就是该字段不是粗体。</li>
</ul>
<h4 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h4><ul>
<li>static称为静态文件夹，是不变的，形成网站的核心部件。可为Templates模块提供提供支持</li>
<li>media称为媒体文件夹，是变动的，由用户定义的文件。可为富文本编辑器mdeditor提供支持</li>
</ul>
<h4 id="配置static目录"><a href="#配置static目录" class="headerlink" title="配置static目录"></a>配置static目录</h4><p>静态文件处理一般分为debug模式和非debug模式</p>
<ul>
<li><p>debug模式下允许访问静态资源，无需STATIC_ROOT</p>
</li>
<li><p>非debug模式即为生产模式。</p>
<ul>
<li><p>STATIC_URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = &#x27;/static/&#x27;</span><br></pre></td></tr></table></figure>

<p>通过url访问static文件的路径，让浏览器可以直接访问静态文件</p>
</li>
<li><p>STATIC_ROOT：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># BASE_DIR 是项目的绝对地址</span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, &#x27;xxxxxx&#x27;)</span><br></pre></td></tr></table></figure>

<p>在服务器上储存static文件的路径。（部署时，将App下所有static文件复制至该文件夹下）</p>
</li>
<li><p>STATICFILES_DIRS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, &#x27;common_static&#x27;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>开发模式时，先到该文件夹查找静态文件，其次到各个APP的static文件夹查找</p>
<p>（同时，查找为惰性查找，查找到第一个，就停止查找）</p>
</li>
</ul>
</li>
</ul>
<h4 id="配置media目录"><a href="#配置media目录" class="headerlink" title="配置media目录"></a>配置media目录</h4><ul>
<li>MEDIA_ROOT：设置用户上传文件的实际保存目录，该文件夹自动创建</li>
<li>MEDIA_URL： 代表用户通过URL来访问这个本地地址的URL</li>
</ul>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p>​	允许若干个发送者通知一组接收者某些特定操作或事件已经发生，	接收者收到信号后去执行特定的操作。</p>
<ul>
<li>post_save：可用于创建关联对象，发送通知等</li>
</ul>
<h4 id="周总结"><a href="#周总结" class="headerlink" title="周总结"></a>周总结</h4><ul>
<li>计划完善论坛功能</li>
<li>完善的同时明晰知识点</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/06/Django(3)/" data-id="cm4tyjjjy0004ekf58qwpgr4w" data-title="Django3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/02/%E6%B5%8B%E8%AF%95/">测试</a>
          </li>
        
          <li>
            <a href="/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/">关于部署平台时的问题</a>
          </li>
        
          <li>
            <a href="/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/">关于K8s和Knative</a>
          </li>
        
          <li>
            <a href="/2024/11/13/%E6%97%A0%E6%9C%8D%E5%8A%A1%E7%99%BD%E7%9A%AE%E4%B9%A6-11-13/">无服务白皮书(11.13)</a>
          </li>
        
          <li>
            <a href="/2024/11/06/2024-11-6/">2024-11-6</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>