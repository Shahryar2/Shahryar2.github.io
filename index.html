<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-性能测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/24/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-12-24T11:30:56.000Z" itemprop="datePublished">2024-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/24/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><ul>
<li><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><h5 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h5></li>
<li><h5 id="压力"><a href="#压力" class="headerlink" title="压力"></a>压力</h5></li>
<li><h5 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h5></li>
<li><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5></li>
<li><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5></li>
</ul>
</li>
<li><h4 id="核心指标"><a href="#核心指标" class="headerlink" title="核心指标"></a>核心指标</h4></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/24/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" data-id="cm7tvl3k80002p4v0hu47di48" data-title="性能测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-postman" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/22/postman/" class="article-date">
  <time class="dt-published" datetime="2024-12-22T08:52:17.000Z" itemprop="datePublished">2024-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/22/postman/">postman</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><ul>
<li><h5 id="postman-echo"><a href="#postman-echo" class="headerlink" title="postman echo"></a>postman echo</h5><!--第一个postman使用实例中：GET postman-echo.com/get-->

<ul>
<li><p>测试REST客户端进行示例API调用的服务；</p>
<img src="C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20241222165438466.png" alt="image-20241222165438466" style="zoom:100%;" /></li>
</ul>
<!--如图所示，HTTP请求从服务器检索数据-->

<ul>
<li><p><strong>post</strong> 将数据传输到服务器并引发响应</p>
<p><strong>put</strong> 与post功能相同</p>
<p><img src="C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20241223195941804.png" alt="image-20241223195941804"></p>
<p><img src="C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20241223200011489.png" alt="image-20241223200011489"></p>
</li>
<li><p><strong>patch</strong> 更新服务器上的资源；</p>
<!--支持查询字符串参数和请求正文--></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/22/postman/" data-id="cm7tvl3k30000p4v06yu53ssu" data-title="postman" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-自动化测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-12-02T07:22:04.000Z" itemprop="datePublished">2024-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><ul>
<li><h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><p>划分有效等价和无效等价</p>
<!--eg ：长度/类型；即采取控制变量法，先拆取规则-->

<hr>
</li>
<li><h4 id="Selenium框架"><a href="#Selenium框架" class="headerlink" title="Selenium框架"></a>Selenium框架</h4><p>Web应用程序测试，只能测试Web应用程序；</p>
<ul>
<li><p>安装框架</p>
</li>
<li><p>下载浏览器驱动，将可执行文件放置在Python环境变量配置目录；</p>
<!--即Python安装目录-->

<!--可能出现无法找到该驱动程序的环境变量的问题-->

<!--驱动实例开启会话时直接将环境变量指向驱动程序路径-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver = webdriver.Edge(executable_path=r&quot;D:\path\msedgedriver.exe&quot;)</span><br></pre></td></tr></table></figure>

</li>
<li><h5 id="打开网页"><a href="#打开网页" class="headerlink" title="打开网页"></a>打开网页</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(&quot;网址&quot;)</span><br></pre></td></tr></table></figure>

</li>
<li><h4 id="等待方式"><a href="#等待方式" class="headerlink" title="等待方式"></a>等待方式</h4><ul>
<li><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">time.sleep(3)</span><br><span class="line">或</span><br><span class="line">from time import sleep </span><br><span class="line">sleep(3)</span><br></pre></td></tr></table></figure>

<!--关闭页面的时间，等待3秒，强制等待，需要导入-->
</li>
<li><h5 id="implicitly-wait"><a href="#implicitly-wait" class="headerlink" title="implicitly_wait"></a>implicitly_wait</h5><!--智能等待（隐形等待），不需要导入-->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(&#x27;//*[@id=&quot;s-top-loginbtn&quot;]&#x27;).click()</span><br></pre></td></tr></table></figure>

<p>满足条件及关闭；</p>
</li>
<li><h5 id="WebDriverWait-常用"><a href="#WebDriverWait-常用" class="headerlink" title="WebDriverWait(常用)"></a>WebDriverWait(常用)</h5><!--显性等待-->

<!--需要明确等待条件和等待上限-->

<!--场景：操作引起页面的变化，要操作变化的元素时，要使用显性等待-->

<p>需要传入的参数：</p>
<!--1.driver：浏览器驱动-->

<!--2.timeout：等待上限（秒）-->

<!--3.poll_frequency：检测的轮询间隔（默认0.5秒）-->

<!--4.ignored_exceptions：超时后抛出的异常信息-->

<hr>
</li>
</ul>
</li>
<li><h4 id="常用方法和模块"><a href="#常用方法和模块" class="headerlink" title="常用方法和模块"></a>常用方法和模块</h4><ul>
<li><h5 id="Expected-Conditions模块"><a href="#Expected-Conditions模块" class="headerlink" title="Expected Conditions模块"></a>Expected Conditions模块</h5><p>和<strong>WebDriverWait</strong>配合使用，动态等待页面上元素出现或者消失；</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nbkhic/p/4885041.html">python selenium expected_conditions使用实例 - 乙醇 - 博客园 (cnblogs.com)</a></p>
</li>
<li><h5 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h5><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38648367/article/details/127729489">Python+selenium自动化八大元素定位方法及实例（超详细）_selenium通过属性定位-CSDN博客</a></p>
<!--基本语法：driver.find_element(By.属性,"value")-->
</li>
<li><h5 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element_to_be_clickable()</span><br></pre></td></tr></table></figure>

<!--返回节点元素，即为可点击节点-->

<!--参考： (https://blog.csdn.net/weixin_45081575/article/details/112306723)-->
</li>
<li><h5 id="ActionChains模块"><a href="#ActionChains模块" class="headerlink" title="ActionChains模块"></a>ActionChains模块</h5><!--动作链-->

<!--适用情况：需要鼠标操作时-->

<p>调用时不会立刻执行，将所有操作顺序按顺序放在一个队列里，调用perform()时，时间依次执行；</p>
<ul>
<li><h5 id="链式写法"><a href="#链式写法" class="headerlink" title="链式写法"></a>链式写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu = driver.find_element_by_css_selector(&quot;.nav&quot;)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(&quot;.nav #submenu1&quot;)</span><br><span class="line">ActionChains(driver).move_to_element(menu).click(hidden_submenu).perform()</span><br></pre></td></tr></table></figure>

<!--先找到页面元素，move_to_element指让鼠标指针移动到该元素上，模拟点击动作-->
</li>
<li><h5 id="分布写法"><a href="#分布写法" class="headerlink" title="分布写法"></a>分布写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu = driver.find_element_by_css_selector(&quot;.nav&quot;)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(&quot;.nav #submenu1&quot;)</span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line">actions.move_to_element(menu)</span><br><span class="line">actions.click(hidden_submenu)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>具体方法见：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxbmaomao/p/10389786.html">Selenium之动作链（ActionChains） - liangxb - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h4 id="unittest框架"><a href="#unittest框架" class="headerlink" title="unittest框架"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=unittest&spm=1001.2101.3001.7020">unittest</a>框架</h4><p>python自带单元测试框架；</p>
<p>一般是最小可测试单元在与其他程序部分隔离的情况下进行检查和验证；</p>
<!--一般最小可测试单元指函数或类-->

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54219272/article/details/123265794">自动化测试——unittest框架_加上unittest测试框架,数据驱动,数据断言等内容。-CSDN博客</a></p>
<h5 id="核心元素："><a href="#核心元素：" class="headerlink" title="核心元素："></a>核心元素：</h5><ul>
<li><h5 id="TestCase（测试用例）"><a href="#TestCase（测试用例）" class="headerlink" title=". TestCase（测试用例）"></a><strong>. TestCase（测试用例）</strong></h5></li>
<li><h5 id="TestSuite-测试套件"><a href="#TestSuite-测试套件" class="headerlink" title=". TestSuite(测试套件)"></a>. TestSuite(测试套件)</h5><!--用来组装打包管理多个测试用例文件的-->
</li>
<li><h5 id="TestRunner-测试执行）"><a href="#TestRunner-测试执行）" class="headerlink" title=". TestRunner(测试执行）"></a>. TestRunner(测试执行）</h5><!--执行TestUite测试套件的-->
</li>
<li><h5 id="TestLoader-装载器）"><a href="#TestLoader-装载器）" class="headerlink" title=". TestLoader(装载器）"></a>. TestLoader(装载器）</h5><!--搜索指定文件夹内指定字母开头的模块下test开始的方法并将符合要求的方法加载到测试套件中-->

<ol>
<li>根据测试类加载测试用例</li>
<li>根据测试模块（测试类所处模块）加载测试用例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from test_math_method import TestMathMethod</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line">loader = unittest.TestLoader()</span><br><span class="line"></span><br><span class="line">#从测试模块里面加载测试用例</span><br><span class="line">suite.addTest(loader.loadTestsFromTestCase(TestMathMethod))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">import test_math_method</span><br><span class="line">#from test_math_method import TestMathMethod</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line">loader = unittest.TestLoader()</span><br><span class="line"></span><br><span class="line">suite.addTest(loader.loadTestsFromModule(test_math_method))</span><br></pre></td></tr></table></figure>

<!--两个方法没有很大的区别，第一个是从文件中导入测试类进行测试；-->

<!--第二个是先导入测试文件，从模块中直接加载测试用例-->
</li>
<li><h5 id="Fixture-固定装置）"><a href="#Fixture-固定装置）" class="headerlink" title=". Fixture(固定装置）"></a>. Fixture(固定装置）</h5><!--两个固定的函数，一个初始化时使用，一个结束时使用--></li>
</ul>
<hr>
<h5 id="用例规则："><a href="#用例规则：" class="headerlink" title="用例规则："></a>用例规则：</h5><ul>
<li><p>导包</p>
<!--import unittest-->
</li>
<li><p>测试类继承unittest.TestCase</p>
</li>
<li><p>测试方法必须以test_开头</p>
</li>
</ul>
<h5 id="方法级别："><a href="#方法级别：" class="headerlink" title="方法级别："></a>方法级别：</h5><ul>
<li><p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def setUp()</span><br></pre></td></tr></table></figure>

<p>测试方法执行前</p>
</li>
<li><p>释放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def tearDown()</span><br></pre></td></tr></table></figure>

<p>测试方法执行后</p>
</li>
</ul>
<!--与此相同的还有类级别，setUpClass();tearDownClass()-->

<!--类方法使用 @classmethod 修饰-->

<hr>
<h5 id="断言："><a href="#断言：" class="headerlink" title="断言："></a>断言：</h5><!--程序判断预期结果和实际结果是否相符-->

<ul>
<li><p>使用方法：</p>
<p>self.断言方法</p>
<!--eg：self.assert'表达式'(预期值，实际值);句式：assertEqual,assertTrue--></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h4 id="Robot-Framwork框架"><a href="#Robot-Framwork框架" class="headerlink" title="Robot Framwork框架"></a>Robot Framwork框架</h4></li>
</ul>
<hr>
<ul>
<li><h4 id="具体内容："><a href="#具体内容：" class="headerlink" title="具体内容："></a>具体内容：</h4><ul>
<li><p>接口测试</p>
</li>
<li><p>UI测试</p>
</li>
<li><p>持续集成</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><ul>
<li><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><h5 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h5></li>
<li><h5 id="压力"><a href="#压力" class="headerlink" title="压力"></a>压力</h5></li>
<li><h5 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h5></li>
<li><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5></li>
<li><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5></li>
</ul>
</li>
<li><h4 id="核心指标"><a href="#核心指标" class="headerlink" title="核心指标"></a>核心指标</h4><ul>
<li><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5>吞吐量&#x3D;总请求数&#x2F;测试持续时间</li>
</ul>
</li>
</ul>
<hr>
<h4 id="一些有用的知识"><a href="#一些有用的知识" class="headerlink" title="一些有用的知识"></a>一些有用的知识</h4><ul>
<li><h5 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h5><h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><ul>
<li><p>标准接口规范，处理HTML和XML文件的标准API;</p>
</li>
<li><p>中立于平台和语言的接口，允许程序和脚本动态访问，更新文档的内容结构和样式；</p>
</li>
</ul>
<h5 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h5><ul>
<li><h5 id="元素："><a href="#元素：" class="headerlink" title="元素："></a>元素：</h5><p>文档中都有标签的为元素</p>
</li>
<li><h5 id="节点："><a href="#节点：" class="headerlink" title="节点："></a>节点：</h5><p>都有的内容是节点</p>
<!--标签，属性，文本-->
</li>
<li><h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p>一个页面是一个文档</p>
</li>
</ul>
<p>文档包含节点，节点包含元素；</p>
<h5 id="类似于："><a href="#类似于：" class="headerlink" title="类似于："></a>类似于：</h5><p><img src="https://img2020.cnblogs.com/blog/2340361/202109/2340361-20210910201929078-1181253470.gif"></p>
<h5 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction() &#123; document.getElementById(&quot;p1&quot;).innerHTML = &quot;我喜欢吃&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=&quot;p1&quot;&gt;我喜欢吃藕&lt;/p&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;试一试&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;上面的段落被一段脚本改变了。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<!--修改了一段内容-->

<hr>
</li>
<li><h5 id="unittest"><a href="#unittest" class="headerlink" title="unittest"></a>unittest</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suite1 = unittest.TestLoader().discover(&#x27;Test1&#x27;, pattern = &quot;Test*.py&quot;)</span><br><span class="line">suite2 = unittest.TestLoader().discover(&#x27;Test2&#x27;, pattern = &quot;Test*.py&quot;)</span><br><span class="line">alltests = unittest.TestSuite((suite1, suite2))</span><br><span class="line">unittest.TextTestRunner(verbosity=2).run(alltests)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先在指定的目录下搜寻指定文件；</p>
<!--pattern= ：指定文件名模式，表示加载文件名以Test开头以.py结尾的文件-->
</li>
<li><p>将测试用例或套件整合到一个测试套件内执行；</p>
</li>
<li><p>执行测试；</p>
<!--verbosity=2 :指详细的输出（包括测试的名称和运行结果）--></li>
</ul>
<hr>
</li>
<li><h5 id="Python查缺补漏"><a href="#Python查缺补漏" class="headerlink" title="Python查缺补漏"></a>Python查缺补漏</h5><ul>
<li><h5 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h5><p><code>sys.stdout</code>表示标准输出流</p>
<p><code>sys.stderr</code>标准错误流</p>
</li>
<li><h5 id="日志处理模块（logging）"><a href="#日志处理模块（logging）" class="headerlink" title="日志处理模块（logging）"></a>日志处理模块（logging）</h5><!--参考文章：https://www.cnblogs.com/yyds/p/6901864.html -->

<ul>
<li><p>使用提供的模块级函数</p>
<!--对日志系统相关类的封装-->

<p><code>logging.basicConfig(**kwargs)</code>：对root logger 进行一次性配置</p>
<!--eg : logging.debug(msg, *args, **kwargs) | 创建一条严重级别为DEBUG的日志记录-->
</li>
<li><p>使用日志系统的组件</p>
<p><code>loggers</code>：代码直接使用的接口；</p>
<p><code>handlers</code>：日志记录发到指定的位置；</p>
<p><code>filters</code>：日志过滤功能；</p>
<p><code>formatters</code>：输出格式</p>
</li>
</ul>
</li>
</ul>
<p>格式输出解释：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(format=&#x27;%(levelname)s:%(message)s - %(user)s&#x27;, level=logging.DEBUG)</span><br></pre></td></tr></table></figure>

<!--%(levelname)s：表示日志级别名称，根据日志的级别动态填充相应值-->

<hr>
<h5 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h5><h5 id=""><a href="#" class="headerlink" title=""></a><!--文章参考：https://blog.csdn.net/qq_41982594/article/details/121071043 --></h5><ul>
<li><h5 id="failfast-快速故障"><a href="#failfast-快速故障" class="headerlink" title="failfast-快速故障"></a>failfast-快速故障</h5><p>旨在停止正常操作而不是尝试可能有问题的过程；</p>
<!--检测错误并停止-->

</li>
<li><h5 id="failsafe-故障安全"><a href="#failsafe-故障安全" class="headerlink" title="failsafe-故障安全"></a>failsafe-故障安全</h5><p>出现特定类型故障可以忽略；</p>
<p>系统在故障前后安全状态一致</p>
<!--不会造成损害或损害较小在可接受范围内的故障-->

</li>
<li><h5 id="faIl-silent-故障沉默"><a href="#faIl-silent-故障沉默" class="headerlink" title="faIl silent-故障沉默"></a>faIl silent-故障沉默</h5><p>调用服务失败，不在分配请求流量并隔离错误；</p>
<!--防止请求堆积消耗线程等资源--></li>
</ul>
<hr>
<ul>
<li><h3 id="流量录制和回放"><a href="#流量录制和回放" class="headerlink" title="流量录制和回放"></a>流量录制和回放</h3><p>记录线上流量，在开发或测试环境中回放；</p>
<!--eg.记录开源网络监测工具为GoReplay（不是代理而是在后台侦听网络接口的流量）-->

<!--具体来说，指将生产环境的日志即记录的真实用户请求按一定的时间顺序和负载模式重新发至目标系统，模拟真实的流量行为-->

<ul>
<li><h5 id="回放"><a href="#回放" class="headerlink" title="回放"></a>回放</h5><!--参考文章：[浅谈“流量回放”-CSDN博客](https://blog.csdn.net/972301/article/details/142389288) -->

<hr>
<!--技术原理-->

<ul>
<li><p>数据捕获</p>
<!--包括HTTP请求，响应头，请求体等-->
</li>
<li><p>数据储存</p>
<p>储存在可重用格式中；</p>
</li>
<li><p>数据回放</p>
<p>储存的请求数据重新发送至应用程序中；</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h5 id="单接口压测"><a href="#单接口压测" class="headerlink" title="单接口压测"></a>单接口压测</h5><p>在开发阶段对单个接口进行性能测试；</p>
</li>
<li><h5 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h5><!--文章参考： https://www.cnblogs.com/ceshi2016/p/16807648.html -->

<p>完全模拟真实用户施压场景在生产环境或类生产环境执行的压测；</p>
<ul>
<li>服务器，中间件，数据库等软硬件配置与线上一致；</li>
<li>压测场景上，通过流量录制回放模拟真实场景；</li>
<li>调用链路使用全链路调通，不做&#x2F;少做mock;</li>
</ul>
<!--mock：用虚拟组件代替实际的服务（返回的是预设的数据而不是真正请求的处理）-->

<p>分为四个部分：</p>
<ul>
<li><h5 id="流量分区"><a href="#流量分区" class="headerlink" title="流量分区"></a>流量分区</h5><p>增加压测标识并在整个压测链路上保持压测标识和线上真实流量区分开；</p>
<!--区分生产流量和压测流量-->
</li>
<li><h5 id="存储隔离"><a href="#存储隔离" class="headerlink" title="存储隔离"></a>存储隔离</h5><p>使用的数据库，缓存，中间件通过上游请求是否有压测标志判断是否为压测流量；</p>
<p><strong>数据库：</strong></p>
<ol>
<li><p>开始前导出生产环境的数据表复制生成一份影子表；</p>
<!--影子表：生产环境中真实数据表的副本，存在目的是使压测流量完全独立于生产流量，避免干扰-->
</li>
<li><p>通过上游传递的压测标志判断请求为压测流量还是生产流量；</p>
<p>压测流量：切换至影子表；否则生产表；</p>
</li>
<li><p>根据表示读取数据（读数据与写数据）；</p>
</li>
</ol>
<p><strong>缓存：</strong></p>
<ol>
<li>配置影子缓存（通过命名空间或独立的实例实现）；</li>
<li>同上；压测流量，影子缓存；否则生产缓存；</li>
<li>读或写操作；</li>
</ol>
<p><strong>中间件&#x2F;消息队列层面：</strong></p>
<!--消息队列的生产者，消费者需要消息体或元数据传递压测标志进行识别-->

<ol>
<li><p>消息生产者生成消息是判断当前流量是否为压测流量；</p>
<p>是则在消息属性中附件压测标志&#x2F;写入消息体中；</p>
</li>
<li><p>消息消费者接收消息检查压测标志决定处理路径：</p>
<ul>
<li><strong>生产流量：</strong>使用生产数据库或缓存；</li>
<li><strong>压测流量：</strong>使用影子表或影子缓存；</li>
</ul>
</li>
<li><p>读或写数据；</p>
</li>
</ol>
</li>
<li><h5 id="参数偏移"><a href="#参数偏移" class="headerlink" title="参数偏移"></a>参数偏移</h5><p>通过改变参数的起始值，范围或分布使请求数据与生产环境数据更加真实避免数据干扰；</p>
<p>可模拟边界条件和不同的负载模式；</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>用户请求参数不同，可通过参数偏移模拟多个用户登录；</li>
<li>避免相同参数造成资源冲突；</li>
<li>控制偏移范围，测试系统对异常参数，极端值的处理能力；</li>
<li>避免直接覆盖生产数据；</li>
</ul>
<p>eg:</p>
<p>通常分为三种偏移方式：</p>
<p><strong>固定</strong>：设定固定偏移值，比如1000000 ；</p>
<p><strong>随机</strong>：在范围内随机生成偏移量；</p>
<p><strong>分段</strong>：参数分成多段，每段生成不同的偏移量；</p>
</li>
<li><h5 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h5><!--基于线上录制回放的施压方式被广泛使用--></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><h5 id="透传"><a href="#透传" class="headerlink" title="透传"></a>透传</h5><ul>
<li><p>透明传输模块；</p>
<p>只负责将业务传输到目的节点，不负责处理传输业务；</p>
<!--相当于数据线或串口线-->
</li>
<li><p>用于读取远程的串口数据；</p>
</li>
</ul>
</li>
<li><h5 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h5><p>两个版本的软件平滑的过度；</p>
</li>
<li><h5 id="RPC请求"><a href="#RPC请求" class="headerlink" title="RPC请求"></a>RPC请求</h5><p>用户调用接口+具体网络协议</p>
<p>（远程调用协议）</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" data-id="cm7tvl3k70001p4v058u230r8" data-title="测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于部署平台时的问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-11-17T08:27:49.000Z" itemprop="datePublished">2024-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/">关于部署平台时的问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="平台Knative"><a href="#平台Knative" class="headerlink" title="平台Knative"></a>平台Knative</h4><ul>
<li>首先Knative建立在K8s集群上；</li>
<li>部署K8s用到的工具：<ul>
<li>docker(podman)</li>
<li>debian</li>
<li>Kubectl</li>
<li>Minikube</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h4><!--详情见[如何在 Debian 11 上使用 Minicube 设置 Kubernetes 集群 (linux-console.net)](https://cn.linux-console.net/?p=4101)-->

<ul>
<li>需要先安装Snap包</li>
<li>用Snap包创建符号链接</li>
<li>添加至配置文件</li>
</ul>
<hr>
<h4 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h4><!--同上-->

<ul>
<li><p>在启动Minikube时，要求podman 最低版本为4.9.0</p>
<ul>
<li><p>更新podman出现了一系列问题导致无法直接更新，从主机github上下载4.9.0的压缩包；</p>
</li>
<li><p>通过xftp传输至debian中进行解压；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf podman-remote-static-linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<!--解压的文件可能不是直接可执行的文件，需移动到正确的位置并重命名-->
</li>
<li><p>赋予执行权力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x 文件路径/podman</span><br></pre></td></tr></table></figure>
</li>
<li><p>容易出现环境变量问题</p>
<p>确认文件是否在目标目录，存在但无法访问，即需添加环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:目录</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>运行时podman易出现驱动问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -n -k podman version --format &#123;&#123;.Version&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将当前用户添加至配置文件，即允许无密码使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br><span class="line">&lt;你的用户名&gt; ALL=(ALL) NOPASSWD:/usr/bin/podman</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>gcr.io 容器注册表连接失败</p>
<!--替换镜像源-->
</li>
<li><p>运行时容易提示无权限：</p>
<p>启用Podman的rootless模式</p>
</li>
<li><p>podman更新后配置易出现问题，如没有正确启动或没有配置好</p>
<ul>
<li><p>首先初始化Podman</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">podman machine init</span><br><span class="line">podman machine start</span><br><span class="line">//检查是否正常启动</span><br><span class="line">podman info</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="cm4tyjjk00008ekf52dmrgw0w" data-title="关于部署平台时的问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于K8s和Knative" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/" class="article-date">
  <time class="dt-published" datetime="2024-11-14T12:57:52.000Z" itemprop="datePublished">2024-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/">关于K8s和Knative</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="关于K8s和Knative"><a href="#关于K8s和Knative" class="headerlink" title="关于K8s和Knative"></a>关于K8s和Knative</h2><h2 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h2><h4 id="组件架构："><a href="#组件架构：" class="headerlink" title="组件架构："></a>组件架构：</h4><ul>
<li><h5 id="控制节点（master）"><a href="#控制节点（master）" class="headerlink" title="控制节点（master）"></a>控制节点（master）</h5><p>四个重要组件：</p>
<ul>
<li><p><strong>ApiServer</strong> </p>
<p>资源操作入口</p>
<!--提供各类型资源对象的增删改查等HTTP Rest接口；-->


</li>
<li><p><strong>Scheduler</strong> </p>
<p>集群资源调度，按策略将Pod调度到node</p>
</li>
<li><p><strong>ControllerManager</strong> </p>
<p>维护集群状态</p>
</li>
<li><p><strong>Etcd</strong> </p>
<p>相当于K8s的数据库</p>
</li>
</ul>
</li>
<li><h5 id="工作节点（node）"><a href="#工作节点（node）" class="headerlink" title="工作节点（node）"></a>工作节点（node）</h5><p>提供环境：</p>
<ul>
<li><strong>Kubelet</strong> </li>
<li><strong>KubeProxy</strong> </li>
<li><strong>Docker</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="Pause"><a href="#Pause" class="headerlink" title="Pause"></a>Pause</h4>  <!--系统容器，特殊容器（infra）容器-->

  <!--每个Pod只有一个pause容器-->

<p>  每个Pod自动创建的容器，不属于用户自定义的容器；</p>
<ul>
<li><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>使同属一个pod的所有容器可以共享一个network namespace;</p>
<!--network namespace：网络资源隔离机制-->

<!--即一个Pod包含容器A和B,使其加入第三方容器（Pause）的network namespace实现存储和网络资源共享-->
</li>
<li><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>pause总是创建的第一个容器，业务依赖于pause容器；</p>
<p>Pod的生命周期&#x3D;pause的生命周期；</p>
</li>
</ul>
<h4 id="init容器"><a href="#init容器" class="headerlink" title="init容器"></a>init容器</h4>  <!--特殊用户容器，类似于pause容器-->

<p>保证应用容器的运行环境；</p>
<p>启动先于应用容器；</p>
<hr>
<h4 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h4><!--确保容器的状态的同时调节负载均衡-->

<!--容器探针类型分为三种：存活/就绪/启动-->

<!--容器探针探测方法-->

<ul>
<li><p>exec：命令实现</p>
<!--部署服务到集群，用命令检查-->

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span>	<span class="comment">#存活探针</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sh</span>	<span class="comment">#通过执行shell命令</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wget</span> <span class="string">-q</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8080</span>	<span class="comment">#wget命令请求该IP（即容器内指定服务是否在8080端口正常运行）</span></span><br><span class="line">      <span class="comment">#-q:不输出任何信息</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">15</span>	<span class="comment">#初始延迟时间（探针等15秒执行第一次检查）</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span>	<span class="comment">#检查频率</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP Socket: TCP套接字检查实现</p>
<!--对容器ip地址上指定端口进行TCP检查，打开或打开连接后立即关闭为健康-->

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>	<span class="comment">#在80端口建立tcp连接</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP GET：HTTP 请求实现</p>
<!--容器ip对应端口和路径执行Http get请求（200<=相应状态码<=400）-->

<p><strong>前置条件：</strong>需容器内启动了http服务并提供了用于探针的接口；</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthy</span>	<span class="comment">#http服务的路径</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>gRPC：gRPC远程过程调用实现</p>
<!--rpc：框架,实现调用远程==调用本地--></li>
</ul>
<hr>
<h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><!--pod中的实现方式和基本架构-->

<ul>
<li><h5 id="网络通信方式"><a href="#网络通信方式" class="headerlink" title="网络通信方式"></a>网络通信方式</h5><p>Kubernetes + Flannel</p>
<ul>
<li><p>Pod 到外网</p>
<p>查找路由表，转发数据包到宿主网卡，宿主网卡完成路由选择；</p>
<p>iptables 或 lvs 执行 Masquerade；</p>
<!--Masquerade：指IP伪装，适用于动态拨号上网的IP伪装（指的是开通宽带后有宽带账号和密码的情况下）-->

<!--Masquerade从服务器的网卡上自动获取当前ip地址做NAT-->
</li>
<li><p><strong>veth-pair</strong></p>
<!--[Linux 虚拟网络设备 veth-pair 详解，看这一篇就够了 - bakari - 博客园 (cnblogs.com)](https://www.cnblogs.com/bakari/p/10613710.html#:~:text=前面这篇文章介绍)-->

<p>虚拟网路接口，一端连接协议栈，一端彼此相连；</p>
<p>三个经典实验，直接相连、通过 Bridge 相连和通过 OVS 相连；</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Ingress规则"><a href="#Ingress规则" class="headerlink" title="Ingress规则"></a>Ingress规则</h4><!--通过该规则将server暴露到外部；管理和配置外部对集群内服务的访问；可定义路由规则-->

<!--具体参考：[k8s 中的 Ingress 简介【k8s 系列之三】 - 橙子家 - 博客园 (cnblogs.com)](https://www.cnblogs.com/hnzhengfy/p/18408742/k8s_ingress)-->

<h5 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h5><h5 id="一个web应用（前端和后端服务），通过Ingress将其暴露到外部"><a href="#一个web应用（前端和后端服务），通过Ingress将其暴露到外部" class="headerlink" title="一个web应用（前端和后端服务），通过Ingress将其暴露到外部"></a>一个web应用（前端和后端服务），通过Ingress将其暴露到外部</h5><!--整个流程是：1.用户通过主机/路径发送http请求；-->

<!--2.Ingress根据相应路径将流量路由到相应service;-->

<!--3.service选择对应的pod，将请求转发给相应容器-->

<h5 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h5><!--定义如何部署前端和后端-->

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>	<span class="comment">#部署资源</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span>	<span class="comment">#前端</span></span><br><span class="line"><span class="attr">spec:</span>	<span class="comment">#规则</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>	<span class="comment">#副本数</span></span><br><span class="line">  <span class="attr">selector:</span>	<span class="comment">#选择</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">frontend</span>	<span class="comment">#选择标签为frontend的pod</span></span><br><span class="line">  <span class="attr">template:</span>	<span class="comment">#pod模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">frontend</span>	<span class="comment">#定于标签为app:frontend/便于匹配</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span>	<span class="comment">#容器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">my-frontend-image:latest</span>	<span class="comment">#使用镜像</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>	<span class="comment">#暴露端口</span></span><br><span class="line"><span class="comment">#前端部署了三个pod，每个pod内部都运行一个web-server容器</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>	<span class="comment">#部署资源</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">backend</span>	<span class="comment">#后端应用</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">api-server</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">my-backend-image:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h5 id="两个service"><a href="#两个service" class="headerlink" title="两个service"></a>两个service</h5><!--为前端和后端应用提供了集群内的访问入口/允许外部流量的访问-->

<!--service在每个pod前面创建一个虚拟IP，从服务暴露的端口映射到pod的端口-->

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>	<span class="comment">#服务资源</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend-service</span>	<span class="comment">#使用ClusterIP（默认类型），只能在集群内部访问</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">frontend</span>	<span class="comment">#选择的是该标签的pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span>	<span class="comment">#协议</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>	<span class="comment">#服务暴露的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>	<span class="comment">#转发到容器的端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">backend-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h5 id="Ingress配置"><a href="#Ingress配置" class="headerlink" title="Ingress配置"></a>Ingress配置</h5><!--管理外部流量/http/https协议-->

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span>	<span class="comment">#基于 host 和 path 来路由流量</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">mydomain.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/frontend</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span>	<span class="comment">#根据路径中/分割的前缀进行匹配</span></span><br><span class="line">        <span class="attr">backend:</span>	<span class="comment">#定义后端service服务的详细信息</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">frontend-service</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/backend</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">backend-service</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mydomain.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">my-tls-secret</span>	<span class="comment">#密钥的名称</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="路由的规则"><a href="#路由的规则" class="headerlink" title="路由的规则"></a>路由的规则</h5><ul>
<li>请求路径以 <code>/frontend</code> 开头的会被路由到 <code>frontend-service</code> 的 80 端口；</li>
<li>请求路径以 <code>/backend</code> 开头的会被路由到 <code>backend-service</code> 的 8080 端口；</li>
</ul>
</li>
<li><h5 id="关于Ingress中支持的path类型"><a href="#关于Ingress中支持的path类型" class="headerlink" title="关于Ingress中支持的path类型"></a>关于Ingress中支持的path类型</h5><ul>
<li><p><strong>ImplementationSpecific</strong></p>
<p>视为单独pathtype&#x2F;Prefix&#x2F;Exact</p>
</li>
<li><p><strong>Exact</strong></p>
<p>精准匹配，区分大小写</p>
</li>
<li><p><strong>Prefix</strong></p>
<p>路径中&#x2F;分割的前缀进行匹配</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="K8s控制器"><a href="#K8s控制器" class="headerlink" title="K8s控制器"></a>K8s控制器</h4><h4 id=""><a href="#" class="headerlink" title=""></a><!--Replicaset和Deployment--></h4><h5 id="无状态应用通常通过Deployment和ReplicaSet管理；"><a href="#无状态应用通常通过Deployment和ReplicaSet管理；" class="headerlink" title="无状态应用通常通过Deployment和ReplicaSet管理；"></a>无状态应用通常通过Deployment和ReplicaSet管理；</h5><h5 id="有状态应用通过StatefulSet来管理；（同时需要配置持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）来管理数据的持久化存储）"><a href="#有状态应用通过StatefulSet来管理；（同时需要配置持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）来管理数据的持久化存储）" class="headerlink" title="有状态应用通过StatefulSet来管理；（同时需要配置持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）来管理数据的持久化存储）"></a>有状态应用通过StatefulSet来管理；（同时需要配置持久卷（PersistentVolume）和持久卷声明（PersistentVolumeClaim）来管理数据的持久化存储）</h5><ul>
<li><h4 id="Replicaset"><a href="#Replicaset" class="headerlink" title="Replicaset"></a><strong>Replicaset</strong></h4><!--等同ReplicationController -->

<p>副本控制器（rs），控制由其管理的pod，使pod副本的数量始终维持在预设的个数；</p>
<ul>
<li><p>组成部分：</p>
<ul>
<li><p><strong>用户期望的pod副本数</strong></p>
</li>
<li><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a><strong>标签选择器</strong></h5><!--选定pod由自己管理--></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="comment">##### **pod资源模板**</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&lt;!--新建pod的模板--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">```yaml</span></span><br><span class="line"><span class="comment">#编写一个ReplicaSet资源清单</span></span><br><span class="line">[<span class="string">root@k8s-master1</span> <span class="string">~</span>]<span class="comment"># cat replicaset.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">guestbook</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">php-redis</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">yecc/gcr.io-google_samples-gb-frontend:v3</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span>  <span class="string">IfNotPresent</span></span><br><span class="line"><span class="string">```</span></span><br></pre></td></tr></table></figure>


<p>​      </p>
<pre><code>- Deployment
</code></pre>
<ul>
<li><h4 id="Deployment-1"><a href="#Deployment-1" class="headerlink" title="Deployment"></a>Deployment</h4><p>提供声明式定义方法来管理一组pod；</p>
<p>即创建deployment来部署replicaset</p>
<!--应用场景：滚动升级和回滚应用、扩容和缩容、暂停和继续-->
</li>
<li><h5 id="statefulset"><a href="#statefulset" class="headerlink" title="statefulset"></a>statefulset</h5><!--等同于deployment-->

<p>区别在为每个Pod维护了一个有粘性的ID；</p>
<!--这些pod基于相同的规则创建因此不能相互替换-->
</li>
<li><h5 id="Daemonset"><a href="#Daemonset" class="headerlink" title="Daemonset"></a>Daemonset</h5><!--pod控制器，确保所有节点都运行一个相同的pod副本-->

<p>和deployment的<strong>区别</strong>：</p>
<p>需要pod副本总运行在全部或特定的主机上，先于其他pod启动；</p>
</li>
</ul>
<hr>
<h5 id="无状态应用"><a href="#无状态应用" class="headerlink" title="无状态应用"></a>无状态应用</h5><p>  不依赖之前的执行状态的应用程序；</p>
<ul>
<li><h5 id="有状态应用"><a href="#有状态应用" class="headerlink" title="有状态应用"></a>有状态应用</h5><p>需要维护和跟踪状态的应用程序；</p>
<h5 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h5><!--无头服务-->

<ul>
<li><h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>Service配置为Headless Service；</p>
<p>Service的<code>clusterIP</code>字段设置为<code>None</code>；</p>
<!--不提供负载均衡直接访问pod，通过IP或DNS名称直接获得Pod列表--></li>
</ul>
</li>
</ul>
<hr>
<h4 id="HPA弹性扩展"><a href="#HPA弹性扩展" class="headerlink" title="HPA弹性扩展"></a>HPA弹性扩展</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><!--自动横向扩展--></h4><p>  使用户根据pod的CPU，内存利用率或其他资源使用情况，自动扩展或缩减pod副本数；</p>
<p>  <strong>Kubernetes Autoscaling</strong> </p>
  <!--使用条件-->

<ul>
<li><p>安装指标服务器；</p>
<p>使用指标服务器API定期扫描pod的指标</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">multi-metric-hpa</span></span><br><span class="line"><span class="attr">spec:</span>	<span class="comment">#自动扩缩器行为的规约</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>	<span class="comment">#指向要扩缩的目标资源（相关指标信息/实际更改副本数）</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-app</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">2</span>	<span class="comment">#负载很低时最小副本数</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span>	<span class="comment">#负载很高时最大副本数</span></span><br><span class="line">  <span class="attr">metrics:</span>	<span class="comment">#定义扩展或缩减的依据指标</span></span><br><span class="line">  <span class="comment">#Resource Metrics（指基于CPU和内存使用情况）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">      <span class="attr">target:</span>	<span class="comment">#属性（利用率）</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">70</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">memory</span>	<span class="comment">#内存资源</span></span><br><span class="line">      <span class="attr">target:</span> </span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">70</span></span><br><span class="line">  <span class="comment">#Pod Metrics（基于自定义的pod级别指标）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">metric:</span>	<span class="comment">#依据指标</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">requests_per_second</span>	<span class="comment">#每个每秒请求数</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">AverageValue</span></span><br><span class="line">        <span class="attr">averageValue:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><h4 id="HPA-Behavior"><a href="#HPA-Behavior" class="headerlink" title="HPA Behavior"></a>HPA Behavior</h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><!--通过behavior配置控制扩缩容的行为--></h4><ul>
<li><p><strong>扩稳定性窗口（Stabilization Window）</strong></p>
<p>避免负载短期内上升引发的频繁扩容；</p>
</li>
<li><h5 id="缩容的延迟（Downscale-Delay）"><a href="#缩容的延迟（Downscale-Delay）" class="headerlink" title="缩容的延迟（Downscale Delay）"></a><strong>缩容的延迟（Downscale Delay）</strong></h5><p>缩容时最小等待时间，避免短期内负载下降时立即缩容；</p>
</li>
<li><p><strong>控制缩放速率</strong></p>
<p>按数量和比例进行副本数调整并周期性检测执行；</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">behavior:</span></span><br><span class="line">    <span class="attr">scaleUp:</span>	<span class="comment">#扩容</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">60</span>  <span class="comment"># 等待 60 秒再进行扩容（等待稳定窗口期）</span></span><br><span class="line">      <span class="attr">policies:</span>	<span class="comment">#策略</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span>	<span class="comment">#指每次扩容按百分比进行</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">100</span>  <span class="comment"># 每次扩容最多增加 100% 的副本数</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">30</span>  <span class="comment"># 每 30 秒检查一次扩容</span></span><br><span class="line">    <span class="attr">scaleDown:</span>	<span class="comment">#缩容</span></span><br><span class="line">      <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>  <span class="comment"># 缩容的稳定窗口为 300 秒</span></span><br><span class="line">      <span class="attr">policies:</span>	</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span>	</span><br><span class="line">        <span class="attr">value:</span> <span class="number">50</span>  <span class="comment"># 每次缩容最多减少 50% 的副本数</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">60</span>  <span class="comment"># 每 60 秒检查一次缩容</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Pod-hook"><a href="#Pod-hook" class="headerlink" title="Pod hook"></a>Pod hook</h3><!--生命周期钩子-->

<p>容器进程启动前或容器进程终止前运行；<!--包含在生命周期之中--></p>
<!--可以同时为Pod中所有容器配置hook-->

<h5 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h5><ul>
<li><h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a><strong>exec</strong></h5><!--执行shell命令-->
</li>
<li><h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><!--执行Http请求--></li>
</ul>
<hr>
<h3 id="Kubectl"><a href="#Kubectl" class="headerlink" title="Kubectl"></a>Kubectl</h3><p>自带客户端，可用来直接操作K8s集群</p>
<ul>
<li><p>K8s命令行工具，可以对其集群运行命令，部署应用，监测管理集群资源和查看日志；</p>
<!--提到集群的控制面：容器编排层，暴露了API和接口来定义，部署容器和管理容器的生命周期-->

<!--原理：输入的转化为REST API调用，将返回结果输出-->

<ul>
<li><h5 id="容器编排层"><a href="#容器编排层" class="headerlink" title="容器编排层"></a>容器编排层</h5><ol>
<li>保证在多个主机上配置和管理容器，保障容器的运行；</li>
<li>自动分配保证负载的平衡；</li>
<li>根据需求自动增减容器的数量（弹性收缩）；</li>
<li>监控容器的健康状态，对出现问题的容器自动重启；</li>
<li>提供容器间的通信机制；</li>
</ol>
</li>
</ul>
</li>
<li><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>使用以下语法从终端窗口运行 <code>kubectl</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl [command] [TYPE] [NAME] [flags]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>command</code>：指具体操作（create,get等）</p>
</li>
<li><p>对类型相同的资源分组</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="一些区分"><a href="#一些区分" class="headerlink" title="一些区分"></a>一些区分</h3><ul>
<li><h4 id="Kubectl-1"><a href="#Kubectl-1" class="headerlink" title="Kubectl"></a>Kubectl</h4><ul>
<li><p>K8s<strong>命令行工具</strong>；</p>
</li>
<li><p>操作K8s集群的工具，允许用户发送请求给K8s API Server管理集群中的资源；</p>
<!--K8s操作的基础工具--></li>
</ul>
</li>
<li><h4 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h4><ul>
<li><p><strong>本地集群工具</strong>，适于开发和测试；</p>
</li>
<li><p>提供轻量级本地集群，简单的环境来运行容器化的应用；</p>
<!--在本地机器启动一个单节点的集群，可用于部署平台,支持虚拟化环境-->

<!--提供本地开发环境--></li>
</ul>
</li>
<li><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><ul>
<li><p>核心组件，节点上的代理程序；</p>
</li>
<li><p>集群中每个节点的守护进程，直接和容器运行时交互；</p>
<!--负责节点管理--></li>
</ul>
</li>
<li><h4 id="Knative"><a href="#Knative" class="headerlink" title="Knative"></a>Knative</h4><ul>
<li>无服务平台</li>
</ul>
</li>
</ul>
<hr>
<h4 id="一些补充的部分"><a href="#一些补充的部分" class="headerlink" title="一些补充的部分"></a>一些补充的部分</h4><ul>
<li><h4 id="RPC，GRPC"><a href="#RPC，GRPC" class="headerlink" title="RPC，GRPC"></a>RPC，GRPC</h4><p>**RPC:**用于调用远程系统上的其他进程，好像调用本地系统一样；</p>
</li>
<li><h4 id="Pod生命周期中的知识点"><a href="#Pod生命周期中的知识点" class="headerlink" title="Pod生命周期中的知识点"></a>Pod生命周期中的知识点</h4><h5 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h5><!--被用来管理容器在运行/关闭前的动作-->

<ul>
<li><p>PostStart</p>
<p>容器创建成功后运行前的任务；</p>
</li>
<li><p>PreStop</p>
<p>被终止前的任务；</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/" data-id="cm4tyjjk00007ekf5ejal04qr" data-title="关于K8s和Knative" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-无服务白皮书-11-13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/13/%E6%97%A0%E6%9C%8D%E5%8A%A1%E7%99%BD%E7%9A%AE%E4%B9%A6-11-13/" class="article-date">
  <time class="dt-published" datetime="2024-11-13T12:27:35.000Z" itemprop="datePublished">2024-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/13/%E6%97%A0%E6%9C%8D%E5%8A%A1%E7%99%BD%E7%9A%AE%E4%B9%A6-11-13/">无服务白皮书(11.13)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="无服务平台"><a href="#无服务平台" class="headerlink" title="无服务平台"></a>无服务平台</h2><h4 id="无服务技术平台"><a href="#无服务技术平台" class="headerlink" title="无服务技术平台"></a>无服务技术平台</h4><ul>
<li><h4 id="Faas"><a href="#Faas" class="headerlink" title="Faas"></a><strong>Faas</strong></h4><p>提供事件驱动的计算</p>
</li>
<li><h4 id="Bass"><a href="#Bass" class="headerlink" title="Bass"></a><strong>Bass</strong></h4><p>基于第三方 API 的服务，代替应用中的常用功能</p>
</li>
<li><p><strong>提到的平台</strong></p>
<p>BaaS 平台，FaaS 平台，OpenWhisk，Cloud Functions、 Azure Functions；</p>
<p>Openfaas、Fission、Kubeless、Knative、 IronFunctions ；</p>
</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p><strong>纯粹按需使用计费</strong></p>
</li>
<li><p><strong>分布式细粒度扩缩容</strong></p>
<p>（满足较小的占用空间，细粒度自动扩缩容）</p>
</li>
<li><p><strong>事件驱动的应用</strong>，Serverless 可以完美适应他们</p>
<p>（基于本地数据获取是否触发函数调用链做基本的决策，未被触发则无服务平台没有资源消耗）</p>
<!--即意味着部署在边缘设备上的收集数据的设备先进行数据收集和基本的决策，边缘系统中可能有预设的函数，若数据值到达某个条件即触发函数-->
</li>
<li><p><strong>无状态生命周期</strong></p>
<p>系统中的函数或任务不依赖过去的历史数据或执行状态，每次都为全新的，适合事件驱动，因为每个事件的处理是全新的；</p>
<!--Unikernel：单地址空间机器镜像,将应用程序和操作系统内核合并成单一镜像的操作系统设计-->
</li>
<li><p><strong>突发工作负载</strong></p>
<!--突发工作负载：系统需应对的、突然出现的高峰流量或大量请求，这些工作负载通常是短暂或间歇性的-->

<p>无服务技术能适应的原因：</p>
<ul>
<li><p><strong>自动扩缩容：</strong></p>
<p>在工作负载增大时，自动扩展资源，减少则释放；</p>
</li>
<li><p><strong>资源供给：</strong></p>
<p>不是提前分配资源而是按需分配；</p>
</li>
</ul>
<p>总体来说能提高系统的响应速度；</p>
</li>
</ul>
<h4 id="雾计算场景下的无服务边缘计算关键特性"><a href="#雾计算场景下的无服务边缘计算关键特性" class="headerlink" title="雾计算场景下的无服务边缘计算关键特性"></a>雾计算场景下的无服务边缘计算关键特性</h4><ul>
<li><p>低时延计算卸载、平台间协同、延时优化、随机数据分析、边缘节点间业务协同、 有状态划分等</p>
<!--雾计算：将计算储存和网络服务从云端推向靠近数据源的边缘节点--></li>
</ul>
<h4 id="技术挑战"><a href="#技术挑战" class="headerlink" title="技术挑战"></a>技术挑战</h4><ul>
<li>冷启动产生的长延时，不实用的为云设计的成本效益模型，持续工作负载和边缘 AI 应用（无 GPU 支持）的不适用性；</li>
<li>缺失位置和能源感知， 未考虑分布式网络，无效的数据迁移，间断资源说明，可靠性和容错 考虑，无效的资源调用的可能性，安全问题，不成熟的函数触发，缺失仿真工具；</li>
</ul>
<h4 id="无服务器边缘计算网络架构"><a href="#无服务器边缘计算网络架构" class="headerlink" title="无服务器边缘计算网络架构"></a>无服务器边缘计算网络架构</h4><!--基础功能-->

<ul>
<li><h5 id="智能业务与应用"><a href="#智能业务与应用" class="headerlink" title="智能业务与应用"></a>智能业务与应用</h5><ul>
<li><p>能自适应和相应动态环境需求的应用，利用边缘计算的低时延，弹性扩展，分布式资源；</p>
</li>
<li><p>通过API（函数即服务）调用和底层网络资源的编排实现跨网络和跨域的无缝协作</p>
<!--API调用：指边缘节点收集到数据后，调用封装的函数分析等--></li>
</ul>
</li>
<li><h5 id="基于Serverless-的服务管理系统"><a href="#基于Serverless-的服务管理系统" class="headerlink" title="基于Serverless 的服务管理系统"></a>基于Serverless 的服务管理系统</h5><!--对各种无服务进行全面的管理，监控和调度-->

<p>通过<strong>管理 Serverless 服务的生命周期</strong>实现协调不同服务之间的调用、资源调度、负载均衡等工作；</p>
<ul>
<li><h5 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h5></li>
<li><h5 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h5><p>将 Serverless 服务（如函数、API 等）自动部署到计算平台上。系统管理平台负责服务的自动化部署、配置和监控；</p>
</li>
<li><h5 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h5><p>在分布式系统中，自动识别并定位网络中可用的服务实例；</p>
</li>
<li><h5 id="服务调度（负载均衡）"><a href="#服务调度（负载均衡）" class="headerlink" title="服务调度（负载均衡）"></a>服务调度（负载均衡）</h5><p>将流量或请求智能地分配到多个可用的服务实例上，以实现高效的资源利用并避免系统过载；</p>
</li>
<li><h5 id="协同调度"><a href="#协同调度" class="headerlink" title="协同调度"></a>协同调度</h5></li>
</ul>
</li>
<li><h5 id="边缘网络控制器及边缘编排管理器"><a href="#边缘网络控制器及边缘编排管理器" class="headerlink" title="边缘网络控制器及边缘编排管理器"></a>边缘网络控制器及边缘编排管理器</h5><ul>
<li><p><strong>边缘网络控制器</strong></p>
<p>连接所有分布式的边缘计算节点，协调节点间的网络通信；</p>
<p>优化数据传输路径和调度策略；</p>
</li>
<li><p><strong>边缘编排管理器</strong></p>
<p>整合所有计算资源和存储资源，自动进行资源调度；</p>
<p>实时扩展或缩减边缘计算节点的计算和存储资源；</p>
<p>确保系统的资源利用最大化，同时根据需求自动扩展或收缩资源。</p>
</li>
</ul>
</li>
<li><h5 id="分布式边缘计算网络基础设施资源"><a href="#分布式边缘计算网络基础设施资源" class="headerlink" title="分布式边缘计算网络基础设施资源"></a>分布式边缘计算网络基础设施资源</h5><p>主要由边缘计算节点和边缘网络设备组成；</p>
</li>
</ul>
<h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><ul>
<li><h5 id="基于-Serverless-的服务管理技术"><a href="#基于-Serverless-的服务管理技术" class="headerlink" title="基于 Serverless 的服务管理技术"></a>基于 Serverless 的服务管理技术</h5><ul>
<li><p>无需管理底层基础设施，专注与编写函数，平台处理资源的分配扩展调度；</p>
</li>
<li><p>核心功能：</p>
<p><strong>服务部署</strong>（确定函数在哪部署和在哪种资源上运行）；<strong>服务发现</strong>（让服务可以被其他组件调用）；</p>
<p><strong>服务调度</strong>（确保高效的负载均衡和资源利用）；</p>
</li>
</ul>
</li>
<li><h5 id="资源管理编排技术"><a href="#资源管理编排技术" class="headerlink" title="资源管理编排技术"></a>资源管理编排技术</h5><p>主要对<strong>容器（K8S实现Docker管理编排）</strong>和<strong>Unikernal</strong>两种计算载体的管理编排进行介绍；</p>
</li>
<li><h5 id="网络控制管理技术"><a href="#网络控制管理技术" class="headerlink" title="网络控制管理技术"></a>网络控制管理技术</h5><!--主要介绍了通过以下两种技术实现“时延确定性”和“路径确定性”-->

<!--时延确定性：数据传输延迟可预测，在时间限制内完成任务-->

<!--路径确定性：数据在网络中传输的路径固定且可靠-->

<ul>
<li><h5 id="软件定义网络（SDN）技术"><a href="#软件定义网络（SDN）技术" class="headerlink" title="软件定义网络（SDN）技术"></a>软件定义网络（SDN）技术</h5><p>用于构建边缘网络的控制面，帮助管理和调度计算、网络和存储资源；</p>
<ul>
<li><h5 id="状态感知："><a href="#状态感知：" class="headerlink" title="状态感知："></a>状态感知：</h5><p>定期上报边缘计算节点和网络设备的状态信息；</p>
</li>
<li><h5 id="任务调度："><a href="#任务调度：" class="headerlink" title="任务调度："></a>任务调度：</h5><p>基于SDN的控制面根据实时的资源状态，选择最适合的边缘计算节点处理请求；</p>
</li>
</ul>
</li>
<li><h5 id="时间敏感网络（TSN）技术"><a href="#时间敏感网络（TSN）技术" class="headerlink" title="时间敏感网络（TSN）技术"></a>时间敏感网络（TSN）技术</h5><p>提供确定性网络传输，确保从一个节点到另一个节点的数据传输具有高度可预测性；</p>
</li>
</ul>
</li>
</ul>
<h4 id="开源生态"><a href="#开源生态" class="headerlink" title="开源生态"></a>开源生态</h4><ul>
<li><h5 id="Knative"><a href="#Knative" class="headerlink" title="Knative"></a>Knative</h5><ul>
<li><p>基于 Kubernetes 和 Istio 的 Serverless 开源实现；2</p>
<!--Istio :开源的服务网格（Service Mesh）框架‘，可以和K8s集成-->

<!--具体作用：1.帮助函数间的调用和流量路由；2.允许函数通过服务发现机制和其他微服务通信和流量负载均衡；3.内建的服务间的加密；-->
</li>
<li><p>只需使用几个 YAML 文件就可以轻松地 开始使用 Knative；</p>
</li>
<li><p>为 了解决容器为核心的 Serverless 应用的构建、部署和运行的问题；</p>
</li>
<li><p>包含<strong>Serving</strong> 和 <strong>Eventing</strong> 两大组件:</p>
<!--通过 Kubernetes custom resource definitions (CRDs)来配置与运行-->

<!--具体解释：扩展K8s的方式，允许用户自定义资源对象让K8s进行调度，监控和管理-->

<ul>
<li><p><strong>Serving</strong></p>
<p>基于 Kubernetes 和 Istio 平台部署，运行无状态的应用 和函数;</p>
<p>控制以下特性Revision （修订版本），Configuration （配置）、Route（路由）和 Service（服 务）实现应用的路由、升级策略、自动扩缩容等功能;</p>
</li>
<li><p><strong>Eventing</strong></p>
<p>事件系统，引入 Source（源）、Channel（通道）和 Subscription（订阅）概念，无需特定代码来选择消息代理，自动完成 事件的绑定和触发；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>OpenFaaS</strong></p>
<p>通过将功能打包，无需重复的样 板化编码，简化操作流程；</p>
<!--用户通过简单的 HTTP 请求（REST API）触发和管理函数-->

<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>易用的UI界面，一键安装；</li>
<li>支持Linux，Windows编写函数，打包Docker镜像；</li>
<li>轻量可移植；</li>
<li>支持命令行工具（YAML制作模板，定义函数）；</li>
</ul>
<p>用户通过 CLI 或者 UI 界面，向 OpenFaas 网关发送 REST API 请求，操作平台功能；</p>
<p>平台上所有的服 务和函数都通过默认路由对外暴露；</p>
</li>
<li><p><strong>OpenWhisk</strong></p>
<ul>
<li><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>功能完备的 FaaS 平台，包含<strong>事件驱动</strong>及函数执行 时等核心组件，可以运行在不同的基础架构上；</p>
</li>
<li><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>庞杂的工具和安全性</p>
</li>
</ul>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><ul>
<li><p><strong>Nginx</strong>：Http 反向代理服务器；</p>
<p>整个系统的入口，接收外部请求转给内部Controller 处理；</p>
</li>
<li><p><strong>Controller</strong> ：为Scala语言实现的REST API；</p>
<p>用于内部对象的 CURD（增删改 查）操作和 Action 调用；</p>
</li>
<li><p><strong>CouchDB</strong>：开源的面向文档的数据库管理系统；</p>
<p>通过检索数据查看用户是否存在以及是否有调用对应 Action 的权限；</p>
<p>加载相应的 Action 及运行参数，存入处理结果；</p>
</li>
<li><p><strong>Load Balancer</strong>：</p>
<p>通过不间断的健康检查，可以获得全局的 Invokers 的状态，知悉哪些可以用于处理动作请求；</p>
</li>
<li><p><strong>Kafka</strong>：提供了消息队列功能；</p>
<p>发出来的所有 Action 调用，都会转化成对应 的消息，在 Kafka 里缓存，等待被执行；</p>
</li>
<li><p><strong>Invoker：</strong>各类 Action 的最终执行者；</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/13/%E6%97%A0%E6%9C%8D%E5%8A%A1%E7%99%BD%E7%9A%AE%E4%B9%A6-11-13/" data-id="cm4tyjjk10009ekf54out7wts" data-title="无服务白皮书(11.13)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2024-11-6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/06/2024-11-6/" class="article-date">
  <time class="dt-published" datetime="2024-11-06T09:06:51.000Z" itemprop="datePublished">2024-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/06/2024-11-6/">2024-11-6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><!--脚本-->

<ul>
<li><h4 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h4><ul>
<li><p><code>env</code>命令总是指向<code>/usr/bin/env</code>文件</p>
<!-- eg: +NAME ，意味着查找环境变量中第一个匹配的NAME。（适用于不知道某命令的具体路径）-->
</li>
<li><p><code>/usr/bin/env bash</code>的意思就是，返回<code>bash</code>可执行文件的位置</p>
<!--当bash路径在环境变量里-->
</li>
<li><p><code>-i</code>, <code>--ignore-environment</code>：不带环境变量启动；</p>
</li>
<li><p><code>-u</code>, <code>--unset=NAME</code>：从环境变量中删除一个变量；</p>
</li>
</ul>
</li>
<li><h4 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h4><ul>
<li><p><code>$0</code>：脚本文件名，即<code>script.sh</code></p>
</li>
<li><p><code>$1</code>~&#96;$9&#96;：对应脚本的第一个参数到第九个参数</p>
</li>
<li><p>+#：参数的总数</p>
</li>
<li><p>+@：全部参数，用空格隔开</p>
</li>
<li><p>+*：全部参数，用变量<code>$IFS</code>值的第一个字符分隔</p>
<!--$IFS：环境变量--></li>
</ul>
<p>命令是<code>command -o foo bar</code>，那么<code>-o</code>是<code>$1</code>，<code>foo</code>是<code>$2</code>，<code>bar</code>是<code>$3</code></p>
</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/06/2024-11-6/" data-id="cm4tyjjjt0000ekf55vbm228p" data-title="2024-11-6" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式-9-8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-8/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T07:00:19.000Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-8/">设计模式-9.8</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li><p>创建一个代理类作为真实对象的中间层，在对该对象访问时进行控制。</p>
<!--例如购买火车票的代售点作为火车站的代理-->
</li>
<li><p>具体步骤</p>
<ul>
<li><p>创建一个接口；</p>
</li>
<li><p>创建实现接口的实体类和代理类；</p>
<!--代理类通过引用实体类，实现功能-->
</li>
<li><p>实现用户需求；</p>
</li>
</ul>
</li>
<li><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p><strong>与适配器模式区别</strong></p>
<p>适配器模式改变接口</p>
<pre><code>public class ObjectHeadSetAdapter implements IPhoneInterface &#123;
    
    private AndroidInterface androidInterface;

    public ObjectHeadSetAdapter(AndroidInterface androidInterface) &#123;
        this.androidInterface = androidInterface;
&#125;

    @Override
    public void iphoneHeadSet() &#123;
        androidInterface.androidHeadSet();
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>与装饰器模式区别</strong></p>
<p>装饰器模式用于增强功能</p>
</li>
</ul>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ul>
<li><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>将所有请求处理者通过前一对象记住下一个对象的引用连成一条链；</p>
<p>客户将请求发至责任链上即可</p>
</li>
<li><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><ul>
<li><p><strong>抽象处理者</strong>：定义处理请求的接口（抽象处理方法和后继连接）；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//抽象处理者角色</span><br><span class="line">abstract class Handler</span><br><span class="line">&#123;</span><br><span class="line">    private Handler next;</span><br><span class="line">    public void setNext(Handler next)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next=next; </span><br><span class="line">    &#125;</span><br><span class="line">    public Handler getNext()</span><br><span class="line">    &#123; </span><br><span class="line">        return next; </span><br><span class="line">    &#125;   </span><br><span class="line">    //处理请求的方法</span><br><span class="line">    public abstract void handleRequest(String request);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>具体处理者</strong>：实现处理者的处理方法；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//具体处理者角色1</span><br><span class="line">class ConcreteHandler1 extends Handler</span><br><span class="line">&#123;</span><br><span class="line">    public void handleRequest(String request)</span><br><span class="line">    &#123;</span><br><span class="line">        if(request.equals(&quot;one&quot;)) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;具体处理者1负责处理该请求！&quot;);       </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(getNext()!=null) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;没有人处理该请求！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>客户类</strong>：创建处理链，向链头的具体处理者对象提交申请；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package chainOfResponsibility;</span><br><span class="line">public class ChainOfResponsibilityPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        //组装责任链 </span><br><span class="line">        Handler handler1=new ConcreteHandler1(); </span><br><span class="line">        Handler handler2=new ConcreteHandler2(); </span><br><span class="line">        handler1.setNext(handler2); </span><br><span class="line">        //提交请求 </span><br><span class="line">        handler1.handleRequest(&quot;two&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><ul>
<li><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>定义一种语言的语法表示，提供一个解释器解释该语言中的语句。</p>
<!--解析和执行特定语言或表达式-->
</li>
<li><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><ul>
<li><p><strong>抽象表达式</strong>：解释方法的接口（语法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Expression &#123;</span><br><span class="line">    int interpret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终结符表达式</strong>：表示语法中的基本元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class NumberExpression implements Expression &#123;</span><br><span class="line">    private int number;</span><br><span class="line"></span><br><span class="line">    public NumberExpression(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--举例中指加减法，即定义数字-->
</li>
<li><p><strong>非终结符表达式</strong>：表示复杂的规则（将基本元素即终结符表达式组合起来）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class AddExpression implements Expression &#123;</span><br><span class="line">    private Expression leftExpression;</span><br><span class="line">    private Expression rightExpression;</span><br><span class="line"></span><br><span class="line">    public AddExpression(Expression leftExpression, Expression rightExpression) &#123;</span><br><span class="line">        this.leftExpression = leftExpression;</span><br><span class="line">        this.rightExpression = rightExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return leftExpression.interpret() + rightExpression.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上述为加法，减法同上</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解释器</strong>：实现简单的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class InterpreterPatternDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建表达式：10 + (5 - 2)</span><br><span class="line">        Expression number10 = new NumberExpression(10);</span><br><span class="line">        Expression number5 = new NumberExpression(5);</span><br><span class="line">        Expression number2 = new NumberExpression(2);</span><br><span class="line"></span><br><span class="line">        // 5 - 2</span><br><span class="line">        Expression subtractExpression = new SubtractExpression(number5, number2);</span><br><span class="line"></span><br><span class="line">        // 10 + (5 - 2)</span><br><span class="line">        Expression addExpression = new AddExpression(number10, subtractExpression);</span><br><span class="line"></span><br><span class="line">        // 解释最终的表达式</span><br><span class="line">        int result = addExpression.interpret();</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);  // 输出 13</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-8/" data-id="cm4tyjjk2000dekf55zt71w71" data-title="设计模式-9.8" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式-9-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-4/" class="article-date">
  <time class="dt-published" datetime="2024-09-04T08:44:30.000Z" itemprop="datePublished">2024-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-4/">设计模式(9.4)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>- </p>
<ul>
<li><p>成员<strong>私有的静态的</strong></p>
<!--一个类仅有一个静态成员变量来保存唯一的实例-->
</li>
<li><p>构造方式 <strong>私有的</strong></p>
<!--构造函数被声明为私有的-->
</li>
<li><p>对外暴露的获取访问是 <strong>公有的静态的</strong></p>
<!--提供一个访问的全局访问点--即一个公有的静态方法来获取或创建实例-->

<!--使用public static:意味着该变量属于类的而不是类的实例，可以通过类名.变量名直接访问-->
</li>
<li><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><h4 id="饿汉式-建议使用"><a href="#饿汉式-建议使用" class="headerlink" title="饿汉式(建议使用)"></a><strong>饿汉式</strong>(建议使用)</h4><p>在<strong>类加载</strong>时已经创建好该对象，在程序调用时直接返回该单例对象即可；</p>
<!--即不用等到被调用时再去创建-->

<pre><code>public class Singleton&#123;
//在该类中创建一个该类的对象供外界去使用
private static Singleton instance= new Singleton();

// 构造方法 private 化
private Singleton()&#123;

&#125;

// 得到 Singleton 的实例(唯一途径）
public static Singleton getInstance() &#123;
    return instance;
&#125;
</code></pre>
</li>
<li><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a><strong>懒汉式</strong></h4><p>在程序使用对象前，先<strong>判断该对象是否已经实例化</strong>（判空）；</p>
<p>若已实例化直接返回该类对象，否则则先执行实例化操作；</p>
<ul>
<li><p>线程不安全</p>
<!--不支持多线程，无加锁 synchronized--></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    //在该类中创建一个该类的对象供外界去使用</span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    // 构造方法 private 化</span><br><span class="line">    private Singleton()&#123; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到 Singleton 的实例(唯一途径）</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if (instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程安全</p>
<!--能很好的在多线程工作，效率低-->

<!--public static synchronized Singleton getInstance()--></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-4/" data-id="cm4tyjjk2000bekf58aoaelye" data-title="设计模式(9.4)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2024-8-17（周总结）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/30/2024-8-17%EF%BC%88%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-08-30T05:51:54.000Z" itemprop="datePublished">2024-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/30/2024-8-17%EF%BC%88%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%89/">2024.8.17（周总结）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="周总结"><a href="#周总结" class="headerlink" title="周总结"></a>周总结</h2><ul>
<li><h4 id="目前的任务"><a href="#目前的任务" class="headerlink" title="目前的任务"></a><strong>目前的任务</strong></h4><ul>
<li>翻译总结下周要讲的论文</li>
</ul>
</li>
<li><h4 id="之前未完成的任务"><a href="#之前未完成的任务" class="headerlink" title="之前未完成的任务"></a><strong>之前未完成的任务</strong></h4><ul>
<li>设计模式还没有学完；</li>
<li>自动化运维看了，但是没有实践；</li>
<li>以及shell命令，一半左右的进度；</li>
</ul>
</li>
<li><h4 id="目前计划"><a href="#目前计划" class="headerlink" title="目前计划"></a>目前计划</h4><ul>
<li>先把翻译的论文整理完；</li>
<li>设计模式看一下能不能搞完，把剩下的看完；</li>
<li>实践一下自动化运维；</li>
</ul>
</li>
<li><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h4><p>比上周多一点进度！</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/30/2024-8-17%EF%BC%88%E5%91%A8%E6%80%BB%E7%BB%93%EF%BC%89/" data-id="cm4tyjjjx0002ekf52cm58xqk" data-title="2024.8.17（周总结）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/24/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">性能测试</a>
          </li>
        
          <li>
            <a href="/2024/12/22/postman/">postman</a>
          </li>
        
          <li>
            <a href="/2024/12/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">测试</a>
          </li>
        
          <li>
            <a href="/2024/11/17/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E5%B9%B3%E5%8F%B0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/">关于部署平台时的问题</a>
          </li>
        
          <li>
            <a href="/2024/11/14/%E5%85%B3%E4%BA%8EK8s%E5%92%8CKnative/">关于K8s和Knative</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>